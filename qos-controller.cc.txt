/*
 * quos-controller.cc
 *
 *  Created on: 5 feb 2020
 *      Author: openflow
 */
/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2016 University of Campinas (Unicamp)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Author:  Luciano Chaves <luciano@lrc.ic.unicamp.br>
 */

#define INF 99999

#include <ns3/network-module.h>
#include <ns3/internet-module.h>
#include "qos-controller.h"

NS_LOG_COMPONENT_DEFINE ("QosController");
NS_OBJECT_ENSURE_REGISTERED (QosController);

QosController::QosController ()
{
	NS_LOG_FUNCTION (this);
	SaveServiceEntry("10.1.3.1",std::list<int> {1});
	SaveServiceEntry("10.1.3.2",std::list<int> {1,1});
	SaveServiceEntry("10.1.3.3",std::list<int> {1,2,2});
}

QosController::~QosController ()
{
	NS_LOG_FUNCTION (this);
}

void
QosController::DoDispose ()
{
	NS_LOG_FUNCTION (this);

	m_arpTable.clear ();
	OFSwitch13Controller::DoDispose ();
}

TypeId
QosController::GetTypeId (void)
{
	static TypeId tid = TypeId ("ns3::QosController")
    																																																																																																																																																																																																																																																																																																														.SetParent<OFSwitch13Controller> ()
																																																																																																																																																																																																																																																																																																															.SetGroupName ("OFSwitch13")
																																																																																																																																																																																																																																																																																																															.AddConstructor<QosController> ()
																																																																																																																																																																																																																																																																																																															.AddAttribute ("EnableMeter",
																																																																																																																																																																																																																																																																																																																	"Enable per-flow mettering.",
																																																																																																																																																																																																																																																																																																																	BooleanValue (false),
																																																																																																																																																																																																																																																																																																																	MakeBooleanAccessor (&QosController::m_meterEnable),
																																																																																																																																																																																																																																																																																																																	MakeBooleanChecker ())
																																																																																																																																																																																																																																																																																																																	.AddAttribute ("MeterRate",
																																																																																																																																																																																																																																																																																																																			"Per-flow meter rate.",
																																																																																																																																																																																																																																																																																																																			DataRateValue (DataRate ("256Kbps")),
																																																																																																																																																																																																																																																																																																																			MakeDataRateAccessor (&QosController::m_meterRate),
																																																																																																																																																																																																																																																																																																																			MakeDataRateChecker ())
																																																																																																																																																																																																																																																																																																																			.AddAttribute ("LinkAggregation",
																																																																																																																																																																																																																																																																																																																					"Enable link aggregation.",
																																																																																																																																																																																																																																																																																																																					BooleanValue (true),
																																																																																																																																																																																																																																																																																																																					MakeBooleanAccessor (&QosController::m_linkAggregation),
																																																																																																																																																																																																																																																																																																																					MakeBooleanChecker ())
																																																																																																																																																																																																																																																																																																																					.AddAttribute ("ServerIpAddr",
																																																																																																																																																																																																																																																																																																																							"Server IPv4 address.",
																																																																																																																																																																																																																																																																																																																							AddressValue (Address (Ipv4Address ("10.1.1.1"))),
																																																																																																																																																																																																																																																																																																																							MakeAddressAccessor (&QosController::m_serverIpAddress),
																																																																																																																																																																																																																																																																																																																							MakeAddressChecker ())
																																																																																																																																																																																																																																																																																																																							.AddAttribute ("ServerTcpPort",
																																																																																																																																																																																																																																																																																																																									"Server TCP port.",
																																																																																																																																																																																																																																																																																																																									UintegerValue (9),
																																																																																																																																																																																																																																																																																																																									MakeUintegerAccessor (&QosController::m_serverTcpPort),
																																																																																																																																																																																																																																																																																																																									MakeUintegerChecker<uint64_t> ())
																																																																																																																																																																																																																																																																																																																									.AddAttribute ("ServerMacAddr",
																																																																																																																																																																																																																																																																																																																											"Server MAC address.",
																																																																																																																																																																																																																																																																																																																											AddressValue (Address (Mac48Address ("00:00:00:00:00:01"))),
																																																																																																																																																																																																																																																																																																																											MakeAddressAccessor (&QosController::m_serverMacAddress),
																																																																																																																																																																																																																																																																																																																											MakeAddressChecker ())
																																																																																																																																																																																																																																																																																																																											;
	return tid;
}

void
QosController::SetWeight(std::string weight){
	InputWeight = weight;
}

void
QosController::HandshakeSuccessful (Ptr<const RemoteSwitch> swtch)
{
	NS_LOG_FUNCTION (this << swtch);
	std::cout<<"Vediamo "<< swtch->GetDpId() <<std::endl;


	SendBarrierRequest (swtch);

	ConfigureBorderSwitch_FUB(swtch);
	SendBarrierRequest (swtch); //Per tentare di fargli eseguire tutti i comandi ricevuti prima di questo e poi gli altri, ma non funziona



	if(!ExistSwitchEntry(swtch->GetDpId())){
		/*In caso un nuovo switch si collega al controller, il grafo che rappresenta la rete diventa obsoleto
		 *Vanno quindi resi nulli il grafo e la matrice dei cammini
		 *Rifatta l'esplorazione, rifatto il blocco delle porte della rete, e rigenerata la matrice dei cammini
		 */
		std::cout<<"Conosciuto: "<< swtch->GetDpId() <<std::endl;

		SaveSwitchEntry(swtch->GetDpId(),swtch);
		nSwitch++;

		firstNetworkExplorer=1;
		SendBarrierRequest (swtch);
		//NetworkExplorerFunction();
		switchNetworkExplore(swtch);
		SendBarrierRequest (swtch);
	}
}

ofl_err
QosController::HandleBarrierReply (
		struct ofl_msg_header *msg, Ptr<const RemoteSwitch> swtch,
		uint32_t xid){
	std::cout<<"Barrier Reply with xid: "<< xid<<std::endl;

	// All handlers must free the message when everything is ok
	ofl_msg_free ((struct ofl_msg_header*)msg, 0);
	return 0;
}


ofl_err
QosController::HandlePacketIn (
		struct ofl_msg_packet_in *msg, Ptr<const RemoteSwitch> swtch,
		uint32_t xid)
{
	NS_LOG_FUNCTION (this << swtch << xid);

	//std::cout << "inzio gestione packet in" << std::endl;
	char *msgStr =
			ofl_structs_match_to_string ((struct ofl_match_header*)msg->match, 0);
	NS_LOG_DEBUG ("Packet in match: " << msgStr);
	free (msgStr);

	if (msg->reason == OFPR_ACTION)
	{
		// Get Ethernet frame type
		uint16_t ethType = ExtractEthernetType((struct ofl_match*)msg->match);

		if (ethType == ArpL3Protocol::PROT_NUMBER)
		{

			if(firstNetworkExplorer==1){ //only the first packet-in enable the exploring
				std::cout<<"Prima esplorazione"<<std::endl;
				NetworkExplorerFunction();
				//switchNetworkExplore(GetRemoteSwitch(4));
				firstNetworkExplorer=2;
			}else if(firstNetworkExplorer==2){
				networkGrafe = GrafeGeneration(nSwitch);
				//networkMatrixPath = floydWarshall(networkGrafe,nSwitch);
				//std::list<std::list<int>> kPath = YenKShortestPath(networkGrafe, nSwitch, 1,2,6);

				firstNetworkExplorer = 0;
			}else{
				return HandleArpPacketIn (msg, swtch, xid);
			}
		}
		else if (ethType == Ipv4L3Protocol::PROT_NUMBER)
		{
			//Protocollo di servizio del pacchetto
			uint8_t ipProtocolId = ExtractIpProtocolID((struct ofl_match*)msg->match);
			if(ipProtocolId == UdpL4Protocol::PROT_NUMBER){ //Sarà un pacchetto udp
				return HandleUDPPacketIn(msg, swtch, xid);
			}
			if(ipProtocolId == TcpL4Protocol::PROT_NUMBER){ //Sarà un pacchetto tcp
				return HandleConnectionRequest (msg, swtch, xid);
			}
		}
		else{//Pacchetto NON ancora gestito
			std::cout<< "altro tipo di pacchetto" << std::endl;
		}
	}

	// All handlers must free the message when everything is ok
	ofl_msg_free ((struct ofl_msg_header*)msg, 0);
	return 0;
}



void
QosController::ConfigureBorderSwitch (Ptr<const RemoteSwitch> swtch)
{
	NS_LOG_FUNCTION (this << swtch);
}

void
QosController::ConfigureAggregationSwitch (Ptr<const RemoteSwitch> swtch)
{
	NS_LOG_FUNCTION (this << swtch);
}

void
QosController::ConfigureBorderSwitch_FUB (Ptr<const RemoteSwitch> swtch)
{
	std::cout << "configureBorderSwitch_FUB" << std::endl;
	NS_LOG_FUNCTION (this << swtch);

	// For packet-in messages, send only the first 128 bytes to the controller
	DpctlExecute (swtch, "set-config miss=128");
	/*----------------------------------------------------------------------*/
	//CONCENTRATI QUI
	//std::cout << "Provo ad impostare la regola" << std::endl;

	// Redirect ARP requests to the controller
	DpctlExecute (swtch, "flow-mod cmd=add,table=0,prio=20 "
			"eth_type=0x0806,arp_op=1 apply:output=ctrl");

	//Redirect ARP Reply from any Host to Controller
	DpctlExecute (swtch, "flow-mod cmd=add,table=0,prio=20 "
			"eth_type=0x0806,arp_op=2 apply:output=ctrl");

	//Network explorer packet redirect
	DpctlExecute(swtch,"flow-mod cmd=add,table=0,prio=20 "
			"eth_type=0x0800,ip_proto=17,udp_dst=11000 apply:output=ctrl");

	DpctlExecute(swtch,"flow-mod cmd=add,table=0,prio=1 "
			"eth_type=0x0800 apply:output=ctrl");
	//std::cout << "Regola Impostata" << std::endl;

	if(swtch->GetDpId() == 1){
		//GROUP MOD
		//è una group che seleziona il forwarding sulla base dei weight
		/*
		DpctlExecute(swtch,"group-mod cmd=add,type=sel,group=1 "
				" weight=3,port=any,group=any output=1 "
				" weight=1,port=any,group=any output=2 "
				" weight=3,port=any,group=any output=3");
		 */
		//FLOW MOD
		/*
		DpctlExecute(swtch,"flow-mod cmd=add,table=0,prio=20 "
				"eth_type=0x0800,ip_proto=17,ip_src=10.1.2.1,ip_dst=10.1.3.2 write:group=1");
		 */
	}

	if(swtch->GetDpId() == 2){

	}

	if(swtch->GetDpId() == 3){
		//DpctlExecute(swtch,"flow-mod cmd=add,table=0,prio=20 "
		//		"eth_type=0x0800,ip_proto=17,ip_src=10.1.2.1,ip_dst=10.1.3.2 apply:output=3");
	}

	if(swtch->GetDpId() == 4){
		//DpctlExecute(swtch,"flow-mod cmd=add,table=0,prio=20 "
		//		"eth_type=0x0800,ip_proto=17,ip_src=10.1.2.1,ip_dst=10.1.3.2 apply:output=3");
	}

}



void
QosController::ConfigureAggregationSwitch_FUB (Ptr<const RemoteSwitch> swtch)
{
	NS_LOG_FUNCTION (this << swtch);

}

ofl_err
QosController::HandleUDPPacketIn(
		struct ofl_msg_packet_in *msg, Ptr<const RemoteSwitch> swtch,
		uint32_t xid){
	//std::cout<<"UDP!!!!!"<<std::endl;
	uint16_t udp_dst_port= ExtractUdpPort(OXM_OF_UDP_DST,(struct ofl_match*)msg->match);;

	if(udp_dst_port == networkExplorerUdpPort){ //è un pacchetto di esplorazione di rete
		uint16_t udp_src_port = ExtractUdpPort(OXM_OF_UDP_SRC,(struct ofl_match*)msg->match);
		uint32_t inPort = ExtractInPort((struct ofl_match*)msg->match);

		std::cout<< "pacchetto explorer UDP da: "<< udp_src_port - networkExplorerUdpPort << " in port: "<< inPort << " dello switch: "<< swtch->GetDpId()<< std::endl;

		uint64_t fromSwitch = swtch->GetDpId();
		uint64_t toSwitch = udp_src_port - networkExplorerUdpPort;
		uint32_t portUseInFrom = inPort;

		if(!ExistPortForwardEntry(fromSwitch,toSwitch)){
			SavePortForwardEntry(fromSwitch,toSwitch,portUseInFrom);
			portSwitchConfiguration(fromSwitch,portUseInFrom);
			//fromSwitch ha ricevuto un pacchetto per una certa porta, da uno switch a lui sconosciuto
			//per quella stessa porta sarà reinviato un pacchetto explorere di fromSwitch
			//che sarà ricevuto dal nuovo switch
			if(!ExistPortForwardEntry(toSwitch,fromSwitch)){ //Se non esiste un collegamento inverso, esploriamo quello appena trovato
				std::cout<<"Pacchetto con impostazione inPort"<<std::endl;
				std::cout<< "invio pacchetto explorer UDP per: "<< toSwitch << " in port: "<< inPort << " de switch: "<< fromSwitch<< std::endl;
				switchNetworkExplore(GetRemoteSwitch(fromSwitch),inPort);
			}
		}else{
			std::cout<<"Un pacchetto strano"<<std::endl;
		}
	}else{
		//Gestisci altri pacchetti udp
		//std::cout<< "pacchetto generico UDP (NON EXPLORER)" << std::endl;
	}
	// All handlers must free the message when everything is ok
	ofl_msg_free ((struct ofl_msg_header*)msg, 0);
	//std::cout<< "fine gestione arp packet" << std::endl;
	return 0;
}

ofl_err
QosController::HandleArpPacketIn (
		struct ofl_msg_packet_in *msg, Ptr<const RemoteSwitch> swtch,
		uint32_t xid)
{
	NS_LOG_FUNCTION (this << swtch << xid);
	//std::cout << "HandlerArpPacket" << std::endl;

	Ipv4Address serverIp = Ipv4Address::ConvertFrom (m_serverIpAddress);
	Mac48Address serverMac = Mac48Address::ConvertFrom (m_serverMacAddress);

	// Get ARP operation
	uint16_t arpOp = ExtractArpOperationCode((struct ofl_match*)msg->match);

	// Get input port
	uint32_t inPort = ExtractInPort((struct ofl_match*)msg->match);

	// Get source and target IP address
	Ipv4Address srcIp, dstIp;
	srcIp = ExtractIpv4Address (OXM_OF_ARP_SPA, (struct ofl_match*)msg->match);
	dstIp = ExtractIpv4Address (OXM_OF_ARP_TPA, (struct ofl_match*)msg->match);

	// Get Source MAC address
	Mac48Address srcMac = ExtractMacAddress(OXM_OF_ARP_SHA,(struct ofl_match*)msg->match);
	//Save, if not exist already, ArpEntry
	SaveArpEntry(srcIp,srcMac);

	//Save, if not exist already, IpDestEntry
	SaveIpDestEntry(srcIp,swtch->GetDpId());

	//Generate ad IP based flow to the new entry, to redirect the destination traffic
	std::ostringstream flowDest;
	flowDest << "flow-mod table=0,cmd=add eth_type=0x800,ip_dst="<<srcIp<<" apply:output="<<inPort;
	DpctlExecute(swtch,flowDest.str());

	// Check for ARP request
	if (arpOp == ArpHeader::ARP_TYPE_REQUEST)
	{
		uint8_t replyData[64];

		if(ExistArpEntry(dstIp)){// In caso di ArpEntry presente, mi è stato chiesto il MAC di un host che conosco
			/*
			uint64_t srcSwitchDpId, dstSwitchDpId;
			srcSwitchDpId = swtch->GetDpId();
			dstSwitchDpId = GetIpDestEntry(dstIp);
			std::list<int> path = extractPath(networkMatrixPath,nSwitch,srcSwitchDpId,dstSwitchDpId);
			showElementList(path);
			setFlowModToPathSwitch(path,srcIp,dstIp);
			 */
			ServiceManagerIPbased(networkGrafe,nSwitch,srcIp,dstIp);


			Mac48Address dstMac = GetArpEntry(dstIp);
			Ptr<Packet> pkt = CreateArpReply(dstMac,dstIp,srcMac,srcIp);
			NS_ASSERT_MSG(pkt->GetSize() == 64, "Invalid packet size.");
			pkt->CopyData(replyData,64);

			struct ofl_action_output *action =
					(struct ofl_action_output*)xmalloc (sizeof (struct ofl_action_output));

			this->shortActionOuputCreator(action, OFPP_IN_PORT, 0);//rimandalo alla porta di provenienza del messaggio che non hai saputo gestire

			struct ofl_msg_packet_out reply;
			reply.header.type = OFPT_PACKET_OUT;
			reply.buffer_id = OFP_NO_BUFFER;
			reply.in_port = inPort;
			reply.data_length = 64;
			reply.data = &replyData[0];
			reply.actions_num = 1;
			reply.actions = (struct ofl_action_header**)&action;

			SendToSwitch (swtch, (struct ofl_msg_header*)&reply, xid);
			free (action);

		}else{//In caso di ArpEntry non trovata, ossia, mi è stato chiesto il MAC di un host che non conosco
			//std::cout << "ArpEntry NON trovata, vado in ricerca" <<std::endl;

			Ptr<Packet> pkt = CreateArpRequest(serverMac, serverIp, dstIp);
			NS_ASSERT_MSG(pkt->GetSize() == 64, "Invalid packet size.");
			pkt->CopyData(replyData,64);//copia pkt in replydata che ha una lunghezza di 64 byte

			DpIdRemoteSwitch_t::iterator itr;
			for(itr = m_dpIdTable.begin(); itr != m_dpIdTable.end(); ++itr){

				struct ofl_action_output *action =
						(struct ofl_action_output*)xmalloc (sizeof (struct ofl_action_output));
				this->shortActionOuputCreator(action, OFPP_FLOOD, 0);

				// Send the ARP Reply within an OpenFlow PacketOut message
				struct ofl_msg_packet_out reply;
				reply.header.type = OFPT_PACKET_OUT;
				reply.buffer_id = OFP_NO_BUFFER;
				reply.in_port = OFPP_CONTROLLER;//da chi proviene il messaggio packet_out
				reply.data_length = 64;
				reply.data = &replyData[0];
				reply.actions_num = 1;
				reply.actions = (struct ofl_action_header**)&action;

				SendToSwitch(itr->second, (struct ofl_msg_header*)&reply, xid);
			}
		}
	}else{
		//std::cout<<"Ho ricevuto un reply"<<std::endl;
	}
	// All handlers must free the message when everything is ok
	ofl_msg_free ((struct ofl_msg_header*)msg, 0);
	//std::cout<< "fine gestione arp packet" << std::endl;
	return 0;
}

ofl_err
QosController::HandleConnectionRequest (
		struct ofl_msg_packet_in *msg, Ptr<const RemoteSwitch> swtch,
		uint32_t xid)
{
	NS_LOG_FUNCTION (this << swtch << xid);

	static uint32_t connectionCounter = 0;
	connectionCounter++;

	struct ofl_match_tlv *tlv;
	Ipv4Address serverIp = Ipv4Address::ConvertFrom (m_serverIpAddress);
	Mac48Address serverMac = Mac48Address::ConvertFrom (m_serverMacAddress);

	// Get input port
	uint32_t inPort = ExtractInPort((struct ofl_match*)msg->match);

	// Get Source MAC address
	Mac48Address srcMac = ExtractMacAddress(OXM_OF_ETH_SRC,(struct ofl_match*)msg->match);

	// Get source and destination IP address
	Ipv4Address srcIp, dstIp;
	srcIp = ExtractIpv4Address (OXM_OF_IPV4_SRC, (struct ofl_match*)msg->match);
	dstIp = ExtractIpv4Address (OXM_OF_IPV4_DST, (struct ofl_match*)msg->match);

	// Get source and destination TCP ports
	uint16_t srcPort, dstPort;
	tlv = oxm_match_lookup (OXM_OF_TCP_SRC, (struct ofl_match*)msg->match);
	memcpy (&srcPort, tlv->value, OXM_LENGTH (OXM_OF_TCP_SRC));
	tlv = oxm_match_lookup (OXM_OF_TCP_DST, (struct ofl_match*)msg->match);
	memcpy (&dstPort, tlv->value, OXM_LENGTH (OXM_OF_TCP_DST));

	// Create an ARP request for further address resolution
	SaveArpEntry (srcIp, srcMac);
	uint8_t replyData[64];
	Ptr<Packet> pkt = CreateArpRequest (serverMac, serverIp, srcIp);
	NS_ASSERT_MSG (pkt->GetSize () == 64, "Invalid packet size.");
	pkt->CopyData (replyData, 64);

	struct ofl_action_output *arpAction =
			(struct ofl_action_output*)xmalloc (sizeof (struct ofl_action_output));
	arpAction->header.type = OFPAT_OUTPUT;
	arpAction->port = OFPP_IN_PORT;
	arpAction->max_len = 0;

	// Send the ARP request within an OpenFlow PacketOut message
	struct ofl_msg_packet_out arpRequest;
	arpRequest.header.type = OFPT_PACKET_OUT;
	arpRequest.buffer_id = OFP_NO_BUFFER;
	arpRequest.in_port = inPort;
	arpRequest.data_length = 64;
	arpRequest.data = &replyData[0];
	arpRequest.actions_num = 1;
	arpRequest.actions = (struct ofl_action_header**)&arpAction;

	SendToSwitch (swtch, (struct ofl_msg_header*)&arpRequest, 0);
	free (arpAction);

	// Check for valid service connection request
	NS_ASSERT_MSG (dstIp.IsEqual (serverIp) && dstPort == m_serverTcpPort,
			"Invalid IP address / TCP port.");

	// Select an internal server to handle this connection
	uint16_t serverNumber = 1 + (connectionCounter % 2);
	NS_LOG_INFO ("Connection " << connectionCounter <<
			" redirected to server " << serverNumber);

	// If enable, install the metter entry for this connection
	if (m_meterEnable)
	{
		std::ostringstream meterCmd;
		meterCmd << "meter-mod cmd=add,flags=1,meter=" << connectionCounter
				<< " drop:rate=" << m_meterRate.GetBitRate () / 1000;
		DpctlExecute (swtch, meterCmd.str ());
	}

	// Install the flow entry for this TCP connection
	std::ostringstream flowCmd;
	flowCmd << "flow-mod cmd=add,table=0,prio=1000 eth_type=0x0800,ip_proto=6"
			<< ",ip_src=" << srcIp
			<< "ip_dst=" << m_serverIpAddress
			<< ",tcp_dst=" << m_serverTcpPort
			<< ",tcp_src=" << srcPort;
	if (m_meterEnable)
	{
		flowCmd << " meter:" << connectionCounter;
	}
	flowCmd << " write:group=" << serverNumber;
	DpctlExecute (swtch, flowCmd.str ());

	// Create group action with server number
	struct ofl_action_group *action =
			(struct ofl_action_group*)xmalloc (sizeof (struct ofl_action_group));
	action->header.type = OFPAT_GROUP;
	action->group_id = serverNumber;

	// Send the packet out to the switch.
	struct ofl_msg_packet_out reply;
	reply.header.type = OFPT_PACKET_OUT;
	reply.buffer_id = msg->buffer_id;
	reply.in_port = inPort;
	reply.actions_num = 1;
	reply.actions = (struct ofl_action_header**)&action;
	reply.data_length = 0;
	reply.data = 0;
	if (msg->buffer_id == NO_BUFFER)
	{
		// No packet buffer. Send data back to switch
		reply.data_length = msg->data_length;
		reply.data = msg->data;
	}

	SendToSwitch (swtch, (struct ofl_msg_header*)&reply, xid);
	free (action);

	// All handlers must free the message when everything is ok
	ofl_msg_free ((struct ofl_msg_header*)msg, 0);
	return 0;
}
/***************************************************************************/

void
QosController::NetworkExplorerFunction(){
	std::cout<<"NetworkExplorerFunction"<<std::endl;
	DpIdRemoteSwitch_t::iterator itr;
	for (itr = m_dpIdTable.begin(); itr != m_dpIdTable.end(); ++itr){
		std::cout<<"Per: "<< itr->second->GetDpId()<< std::endl;
		switchNetworkExplore(itr->second);
	}
}


int
QosController::switchNetworkExplore(Ptr<const RemoteSwitch> swtch){
	return switchNetworkExplore(swtch,OFPP_FLOOD);
}

int
QosController::switchNetworkExplore(Ptr<const RemoteSwitch> swtch, uint32_t outputSwitchPort){

	//std::cout<< "Inizio Network Explorer"<< std::endl;
	uint8_t pktExplorer[64];

	Ptr<Packet> pkt = CreateUdpExplorerPacket(swtch->GetDpId());

	pkt->CopyData(pktExplorer,64);

	struct ofl_action_output *action =
			(struct ofl_action_output*)xmalloc (sizeof (struct ofl_action_output));

	shortActionOuputCreator(action, outputSwitchPort ,0);

	struct ofl_msg_packet_out explorer;
	explorer.header.type=OFPT_PACKET_OUT;
	explorer.buffer_id=OFP_NO_BUFFER;
	explorer.in_port=OFPP_CONTROLLER;
	explorer.actions=(struct ofl_action_header**)&action;
	explorer.actions_num=1;
	explorer.data=&pktExplorer[0];
	explorer.data_length=64;

	std::cout<<"Inviato Explorer"<<std::endl;

	return SendToSwitch(swtch,(struct ofl_msg_header*)&explorer,GetNextXid());
}


Ptr<Packet>
QosController::CreateUdpExplorerPacket(uint64_t fromSwitchId){
	//Ipv4Address serverIp = Ipv4Address::ConvertFrom (m_serverIpAddress);
	//Mac48Address serverMac = Mac48Address::ConvertFrom (m_serverMacAddress);

	//std::cout<< "Creo packetto UDP"<< std::endl;
	//uint8_t * hello;
	//uint8_t fromSwitchIdData = (uint8_t)fromSwitchId;
	//uint32_t helloSize=24;
	//hello = (uint8_t*)calloc(helloSize,sizeof(uint8_t));
	//uint8_t  hello[24] = "ciao";

	//reinterpret_cast<const uint8_t*> ("hello"), 5
	//Ptr<Packet> pktU = Create<Packet>(hello,helloSize);
	Ptr<Packet> pktU = Create<Packet>();

	UdpHeader udpH;
	udpH.SetSourcePort(networkExplorerUdpPort+fromSwitchId);
	udpH.SetDestinationPort(networkExplorerUdpPort);
	udpH.EnableChecksums();
	Ipv4Address src="10.1.1.1";
	Ipv4Address dst="10.1.1.1";
	udpH.InitializeChecksum(src,dst,UdpL4Protocol::PROT_NUMBER);
	Buffer buffer;
	//buffer.Serialize(hello,helloSize);

	pktU->AddHeader(udpH);

	Ipv4Header ipv4H;
	ipv4H.SetSource("10.1.1.1");
	ipv4H.SetDestination("10.1.1.1");
	ipv4H.SetTtl(64);
	ipv4H.SetDontFragment();
	ipv4H.SetProtocol(UdpL4Protocol::PROT_NUMBER);
	ipv4H.SetPayloadSize(UdpL4Protocol::PROT_NUMBER);

	pktU->AddHeader(ipv4H);

	// Ethernet header
	EthernetHeader eth (false);
	eth.SetSource ("00:00:00:90:01:01");
	eth.SetDestination ("00:00:00:90:02:01");
	if (pktU->GetSize () < 46)
	{
		uint8_t buffer[46];
		memset (buffer, 0, 46);
		Ptr<Packet> padd = Create<Packet> (buffer, 46 - pktU->GetSize ());
		pktU->AddAtEnd (padd);
	}
	eth.SetLengthType (Ipv4L3Protocol::PROT_NUMBER);
	pktU->AddHeader (eth);

	// Ethernet trailer
	EthernetTrailer trailer;
	if (Node::ChecksumEnabled ())
	{
		trailer.EnableFcs (true);
	}
	trailer.CalcFcs (pktU);
	pktU->AddTrailer (trailer);

	return pktU;
}


void
QosController::portSwitchConfiguration(uint64_t switchDpId, uint32_t port){
	portSwitchConfiguration(GetRemoteSwitch(switchDpId),port);
}

void
QosController::portSwitchConfiguration(Ptr<const RemoteSwitch> swtch, uint32_t port){

	struct ofl_msg_port_mod pkt;
	pkt.header.type=OFPT_PORT_MOD;
	pkt.port_no=port;
	pkt.config=OFPPC_NO_FWD;
	pkt.mask=OFPPC_NO_FWD;
	//pkt.advertise=;

	std::cout << "inviato il blocco" << std::endl;

	SendToSwitch (swtch, (struct ofl_msg_header*)&pkt, GetNextXid());
}

/*******************************************/

int **
QosController::GrafeGeneration(int nSwitch){
	int** grafe = new int*[nSwitch];
	for (int i = 0; i < nSwitch; ++i){
		grafe[i] = new int[nSwitch];
		for(int j = 0; j < nSwitch; ++j){
			grafe[i][j]=INF;
		}
	}
	//std::cout<<"grafo inizializzato"<<std::endl;
	PortForwardFromS1ToS2_t::iterator itr;
	for(itr = m_PortFrowardTable.begin(); itr != m_PortFrowardTable.end(); ++itr){
		grafe[itr->first.first-1][itr->first.second-1]=1;
	}

	std::cout<<"grafo scritto"<<std::endl;
	for(int i=0; i<nSwitch; i++){
		for(int j=0; j<nSwitch; j++){
			std::cout<<grafe[i][j]<<" ";
		}
		std::cout<<std::endl;
	}
	std::cout<<"grafo stampato"<<std::endl;

	return grafe;
}

/*****************************************************/
void printSolution(int** pred, const int V)
{
	std::cout<<"The following matrix shows the path"
			" between every pair of vertices "<<std::endl;
	for (int i = 0; i < V; i++)
	{
		for (int j = 0; j < V; j++)
		{
			if (pred[i][j] == INF)
				std::cout<<"INF"<<"     ";
			else
				std::cout<<pred[i][j]<<"     ";
		}
		std::cout<<std::endl;
	}
}

int **
QosController::floydWarshall (int** graph, const int V)
{

	int i, j, k;

	int** dist = new int*[V];
	int** next = new int*[V];
	for (int i = 0; i < V; ++i){
		dist[i] = new int[V];
		next[i] = new int[V];
		for(int j = 0; j < V; ++j){
			dist[i][j]=0;
			next[i][j]=0;
		}
	}
	for (i = 0; i < V; i++){
		for (j = 0; j < V; j++){
			dist[i][j] = graph[i][j];
			next[i][j] = j;
		}
	}
	for(i = 0; i< V; i++){
		dist[i][i]=0;
		next[i][i]=i;
	}
	for (k = 0; k < V; k++)
	{
		for (i = 0; i < V; i++)
		{
			for (j = 0; j < V; j++)
			{
				if (dist[i][j] > dist[i][k] + dist[k][j]){
					dist[i][j] = dist[i][k] + dist[k][j];
					next[i][j] = next[i][k];
				}
			}
		}
	}
	printSolution(next, V);
	return next;
}
//Inizio Dikjstra
void printPath(int parent[], int j)
{

	// Base Case : If j is source
	if (parent[j] == - 1)
		return;

	printPath(parent, parent[j]);

	printf("%d ", j+1);
}

void printArray(int arr[], int n)
{
	printf("****************************\n");
	for (int i = 0; i < n; i++)
		printf("%d tt %d\n", i, arr[i]);
	printf("****************************\n");
}

int minDistance(int dist[], bool sptSet[], int vertex)
{
	// Initialize min value
	int min = INF, min_index;

	for (int v = 0; v < vertex; v++)
		if (sptSet[v] == false && dist[v] <= min)
			min = dist[v], min_index = v;

	return min_index;
}

std::list<int>
QosController::dijkstraPathExtract(int* parent, int vertex, int src, int dst){
	std::list<int> pathList;

	pathList.push_front(dst+1); //Mette in testa
	int pred=parent[dst];
	while(pred!=-1){
		pathList.push_front(pred+1); //Mette in testa
		pred = parent[pred];
	}
	/*
	std::cout<<"Cammino da "<< src+1<< " a " << dst+1 <<std::endl;
	for (std::list<int>::iterator it=pathList.begin(); it!=pathList.end(); ++it)
		std::cout << ' ' << *it;
	std::cout<< " " << std::endl;
	 */

	return pathList;
}

std::list<int>
QosController::dijkstra(int** graph,int src, int dst, int vertex) //Method to implement shortest path algorithm
{

	src--;
	dst--;
	int dist[vertex]; // The output array. dist[i] will hold the shortest
	// distance from src to i

	bool sptSet[vertex]; // sptSet[i] will be true if vertex i is included in shortest
	// path tree or shortest distance from src to i is finalized

	int parent[vertex];

	// Initialize all distances as INFINITE and stpSet[] as false
	for (int i = 0; i < vertex; i++){
		parent[i] = -1;
		dist[i] = INF;
		sptSet[i] = false;
	}


	// Distance of source vertex from itself is always 0
	dist[src] = 0;

	// Find shortest path for all vertices
	for (int count = 0; count < vertex - 1; count++) {
		// Pick the minimum distance vertex from the set of vertices not
		// yet processed. u is always equal to src in the first iteration.
		int u = minDistance(dist, sptSet, vertex);

		// Mark the picked vertex as processed
		sptSet[u] = true;

		// Update dist value of the adjacent vertices of the picked vertex.
		for (int v = 0; v < vertex; v++)

			// Update dist[v] only if is not in sptSet, there is an edge from
			// u to v, and total weight of path from src to v through u is
			// smaller than current value of dist[v]
			if (!sptSet[v] && graph[u][v] && dist[u] != INF
					&& dist[u] + graph[u][v] < dist[v]){
				parent[v] = u;
				dist[v] = dist[u] + graph[u][v];
			}
	}
	//printArray(dist, vertex);
	if(dist[dst]>=INF){
		//std::cout<<"toFAR"<<std::endl;
		std::list<int> toFar;
		return toFar;
	}

	return dijkstraPathExtract(parent,vertex,src,dst);
}

std::list<std::list<int>>
QosController::HopeKShortestPath(int** graph, int vertex, int src, int dst, int k, int algType){

	std::list<std::list<int>> kPathList;
	std::list<std::list<int>>::iterator kPathListIterator = kPathList.begin();
	std::queue<std::pair<int,int>> edgeQueue;

	std::list<int> lastPathFounded = dijkstra(graph,src,dst,vertex);
	int nPath=1;

	kPathList.insert(kPathListIterator,lastPathFounded);

	std::cout<<"Prima While"<<std::endl;

	while((!lastPathFounded.empty())&&(nPath<k)){

		for(int i = 0; i<vertex; i++){
			for(int j=0; j<vertex; j++){
				std::cout<<" "<< graph[i][j];
			}
			std::cout<<std::endl;
		}
		//Che tipologia di ricerce future deve fare
		if(algType==1){//Senza ripetizioni di nodi atraversati in precedenza
			std::cout<<"No Per Stessi Nodi"<<std::endl;
			std::list<int>::iterator fromIt=lastPathFounded.begin();
			std::list<int>::iterator toIt=lastPathFounded.begin();
			++fromIt;
			++toIt;
			++toIt;
			while(toIt!=lastPathFounded.end()){
				std::cout<<"Elimino Nodo: "<< *fromIt-1 <<std::endl;
				for(int i=0; i<vertex; i++){
					std::cout<<"Elimino Arco: "<< *fromIt << " <-> " << *toIt <<std::endl;
					graph[*fromIt-1][i]=INF;
					graph[i][*fromIt-1]=INF;
				}
				++fromIt;
				++toIt;
			}
		}else{//Con ripetizioni di nodi nodi attraversati in precedenza
			std::cout<<"Si per Nodi"<<std::endl;
			if(algType==2){//Senza passare su archi di altri path
				std::cout<<"Senza stesi archi"<<std::endl;
				std::list<int>::iterator fromIt=lastPathFounded.begin();
				std::list<int>::iterator toIt=lastPathFounded.begin();
				++toIt;
				while(toIt!=lastPathFounded.end()){
					std::cout<<"Elimino Arco: "<< *fromIt << " <-> " << *toIt <<std::endl;
					graph[*fromIt-1][*toIt-1]=INF;
					graph[*toIt-1][*fromIt-1]=INF;
					++fromIt;
					++toIt;
				}
			}else if(algType==3){
				//Con ripetizione di archi di altri path
				//Ma eliminando l'arco del path più pesante
				/*
				std::cout<<"Con ripetizioni di altri path, ma eliminando un arco alla volta"<<std::endl;
				std::list<int>::iterator fromIt=lastPathFounded.begin();
				std::list<int>::iterator toIt=lastPathFounded.begin();
				++toIt;
				std::pair<int,int> arco;
				while(toIt!=lastPathFounded.end()){
					std::cout<<"Memorizzo Archo da eliminare dopo: "<< *fromIt << " <-> " << *toIt <<std::endl;
					arco.first=*fromIt;
					arco.second=*toIt;
					edgeQueue.push(arco);
					++fromIt;
					++toIt;
				}
				//Elimino un arco
				std::cout<<"Elimino Arco: "
				 */

			}
		}

		/*
		for(int i = 0; i<vertex; i++){
			for(int j=0; j<vertex; j++){
				std::cout<<" "<< graph[i][j];
			}
			std::cout<<std::endl;
		}
		 */



		//Cerchiamo il prossimo
		lastPathFounded = dijkstra(graph,src,dst,vertex);
		if(!lastPathFounded.empty())
			kPathList.insert(kPathListIterator,lastPathFounded);


		nPath++;
	}

	//Rigenera grafo originale
	GrafeGeneration(nSwitch);

	std::cout<<"Tutti i cammini estratti"<<std::endl;
	for (std::list<std::list<int>>::iterator kPathListIterator = kPathList.begin(); kPathListIterator!=kPathList.end(); ++kPathListIterator){
		for(std::list<int>::iterator path = (*kPathListIterator).begin(); path!=(*kPathListIterator).end(); ++path)
			std::cout << ' ' << *path;
		std::cout<< " " << std::endl;
	}

	return kPathList;
}



std::list<int> pathFromTo (std::list<int> path, int fromExtract, int toExtract){
	std::list<int> A;
	std::list<int>::iterator AIter = A.begin();

	int pos=0;
	for(std::list<int>::iterator pathIter = path.begin(); pathIter != path.end(); ++pathIter){
		if((fromExtract<=pos)&&(pos<=toExtract)){
			A.insert(AIter,(*pathIter));
		}
		pos++;
	}
	return A;
}

int extractElementFromPath(std::list<int> path, uint64_t pos){
	std::cout<<"Dentro extractElementFromPath"<<std::endl;
	std::list<int>::iterator pathIter;
	uint64_t actualPos = 0;
	for(pathIter = path.begin(); pathIter != path.end(); ++pathIter){
		if(actualPos==pos)
			return (*pathIter);
		actualPos++;
	}
	return -1;
}

bool equalPath(std::list<int> A, std::list<int> B){
	std::list<int>::iterator AIter = A.begin();
	std::list<int>::iterator BIter = B.begin();
	while((AIter != A.end())&&(BIter != B.end())){
		if((*AIter)!=(*BIter))
			return false;
		++AIter;
		++BIter;
	}
	if((AIter == A.end())&&(BIter == B.end()))
		return true;
	return false;
}

std::pair<int,int> getEdge(std::list<int> path, int fromPos, int toPos){
	std::pair<int,int> result;
	std::list<int>::iterator PathIter = path.begin();
	int actualPos = 0;
	while(fromPos!=actualPos){
		actualPos++;
		++PathIter;
	}
	result.first = (*PathIter);
	++PathIter;
	result.second = (*PathIter);
	return result;
}

std::list<int> listConcat(std::list<int> A, std::list<int> B){
	A.reverse();
	std::list<int>::iterator AIter;
	for(AIter = A.begin(); AIter != A.end(); ++AIter){
		B.push_front((*AIter));
	}
	return B;
}

bool inListOfList(std::list<std::list<int>> listOfList, std::list<int> list){
	std::list<std::list<int>>::iterator listOfListIter;
	for(listOfListIter = listOfList.begin(); listOfListIter != listOfList.end(); ++listOfListIter){
		if(equalPath((*listOfListIter),list))
			return true;
	}
	return false;
}

uint64_t pathCost(std::list<int> path, int** grafe){
	std::list<int>::iterator pathIterFrom = path.begin();
	std::list<int>::iterator pathIterTo = path.begin();
	++pathIterTo;
	uint64_t totalPathCost = 0;
	while(pathIterTo != path.end()){
		totalPathCost += grafe[*pathIterFrom-1][*pathIterTo-1];
		++pathIterFrom;
		++pathIterTo;
	}
	return totalPathCost;
}

std::list<int> shortPath(std::list<std::list<int>> listOfList, int ** graph){
	std::list<int> toShort;
	std::list<std::list<int>>::iterator listOfListIter;


	listOfListIter = listOfList.begin();
	toShort = (*listOfListIter);
	uint64_t toShortCost = pathCost(toShort,graph);

	for(++listOfListIter;listOfListIter != listOfList.end(); ++listOfListIter){
		uint64_t controll = pathCost(*listOfListIter,graph);
		if(toShortCost>controll){
			toShort = (*listOfListIter);
			toShortCost = controll;
		}
	}
	return toShort;
}


std::list<std::list<int>>
QosController::YenKShortestPath(int** graph, int vertex, int src, int dst, int k){
	std::list<std::list<int>> A;
	std::list<std::list<int>>::iterator AIter = A.begin();
	std::list<int> lastPathFounded = dijkstra(graph,src,dst,vertex);
	A.insert(AIter,lastPathFounded);
	--AIter; //Server per l'algoritmo che stia al primo argomento

	std::list<std::pair<int,int>> removeEdge;

	std::list<std::list<int>> B;

	for(int i=1; i<k; i++){ //Ho già un path, per questo parto da 1
		//Prendo un nodo chiave che è un nodo di uno dei percorsi avuti in precedenza in ordine

		std::list<int> attuale = (*AIter);
		std::list<std::pair<int,int>> grafeEdge;
		int j=0;
		for(std::list<int>::iterator attualeIter = attuale.begin(); attualeIter != attuale.end(); ++attualeIter){
			if((*attualeIter)!=dst){

				int spurNode = (*attualeIter);//Nodo di partenza

				std::list<int> rootPath = pathFromTo(attuale,0,j);

				//Tolgo il Path del pathRoot fino a qui
				std::list<int>::iterator rootPathIter = rootPath.begin();
				while(rootPathIter != rootPath.end()){
					if(((*rootPathIter)-1) != (spurNode-1)){

						for(int i=0; i<vertex; i++){
							if(graph[(*rootPathIter)-1][i] != INF){
								std::pair<int,int> edge;
								edge.first = ((*rootPathIter));
								edge.second = i+1;
								grafeEdge.push_front(edge);
								//std::cout<<"Edge tolto: " << edge.first << " <-> " << edge.second <<std::endl;
								//Nel frattempo aggiorno il grafo
								graph[edge.first-1][edge.second-1]=INF;
								graph[edge.second-1][edge.first-1]=INF;
							}
						}

					}
					++rootPathIter;
				}
				//Tolgo Archi già presenti nei singoli Path in A
				std::list<std::list<int>>::iterator AIterTwo;
				for(AIterTwo = A.begin(); AIterTwo != A.end(); ++AIterTwo){
					if(equalPath(rootPath,pathFromTo((*AIterTwo),0,j))){
						std::pair<int,int> edge = getEdge((*AIterTwo),j,j+1);
						grafeEdge.push_front(edge);
						//std::cout<<"Edge tolto: " << edge.first << " <-> " << edge.second <<std::endl;
						//Nel frattempo aggiorno il grafo
						graph[edge.first-1][edge.second-1]=INF;
						graph[edge.second-1][edge.first-1]=INF;
					}
				}






				//Ora che ho eliminato gli archi simili ai successivi, prendo il prossimo cammino

				std::list<int> spurPath = dijkstra(graph,spurNode,dst,vertex);//Contiene lo spureNode

				//Siccome rooPath, contiene come ultimo nodo spurNode e spurPath contien spurNode come primo ,elimino il primo elemento di spurPath
				if(!spurPath.empty()){
					spurPath.pop_front();


					//Unisco il mio nuovo percorso diverso dai precedenti
					std::list<int> totalPath = listConcat(rootPath,spurPath);


					if(!inListOfList(A,totalPath))
						B.push_back(totalPath);
				}
				//Re integro gli archi che ho tolto per fare le considerazioni
				for(std::list<std::pair<int,int>>::iterator grafeEdgeIter = grafeEdge.begin(); grafeEdgeIter != grafeEdge.end(); ++grafeEdgeIter){
					std::pair<int,int> edge = (*grafeEdgeIter);
					//std::cout<<"Edge messo: " << edge.first << " <-> " << edge.second <<std::endl;
					graph[edge.first-1][edge.second-1]=1;
					graph[edge.second-1][edge.first-1]=1;
				}

				j++;

			}
		}
		if(B.empty()){
			i=k;
		}else{
			++AIter;
			std::list<int> toRemove = shortPath(B,graph);
			A.insert(AIter,toRemove);
			B.remove(toRemove);
			--AIter;

		}
	}
	//Rigenera grafo originale
	GrafeGeneration(nSwitch);


	std::cout<<"Tutti i cammini estratti"<<std::endl;
	for (std::list<std::list<int>>::iterator AIterTre = A.begin(); AIterTre!=A.end(); ++AIterTre){
		for(std::list<int>::iterator path = (*AIterTre).begin(); path!=(*AIterTre).end(); ++path)
			std::cout << ' ' << *path;
		std::cout<< " " << std::endl;
	}

	return A;
}


std::list<int>
QosController::extractPath(int ** graph, const int V, Ptr<const RemoteSwitch> fromSwtch, Ptr<const RemoteSwitch> toSwtch){
	return extractPath(graph,V,fromSwtch->GetDpId(),toSwtch->GetDpId());
}

std::list<int>
QosController::extractPath(int ** graph, const int V, int from, int to){
	from--;
	to--;
	std::list<int> pathList;
	std::list<int>::iterator it;
	it = pathList.begin();

	//std::cout<<"Cammino: "<<from<<std::endl;

	//std::cout<<"Nodo: "<<from+1<<std::endl;
	pathList.insert(it,from+1);
	while(from!=to){
		//std::cout<<"Nodo: "<< graph[from][to]+1<<std::endl;
		pathList.insert(it,graph[from][to]+1);
		from=graph[from][to];
	}
	return pathList;
}

void
QosController::showElementList(std::list<int> list){
	std::cout<<"showElementList"<<std::endl;
	std::list<int>::iterator it;
	for(it = list.begin(); it!=list.end(); ++it){
		std::cout<<" elemContain: "<< *it<< std::endl;
	}
}

/*****************************************************/
Ipv4Address
QosController::ExtractIpv4Address (uint32_t oxm_of, struct ofl_match* match)
{
	switch (oxm_of)
	{
	case OXM_OF_ARP_SPA:
	case OXM_OF_ARP_TPA:
	case OXM_OF_IPV4_DST:
	case OXM_OF_IPV4_SRC:
	{
		uint32_t ip;
		int size = OXM_LENGTH (oxm_of);
		struct ofl_match_tlv *tlv = oxm_match_lookup (oxm_of, match);
		memcpy (&ip, tlv->value, size);
		return Ipv4Address (ntohl (ip));
	}
	default:
		NS_ABORT_MSG ("Invalid IP field.");
	}
}
Mac48Address
QosController::ExtractMacAddress (uint32_t oxm_of, struct ofl_match* match){
	switch(oxm_of){
	case OXM_OF_ARP_SHA:
	case OXM_OF_ARP_SHA_W:
	case OXM_OF_ARP_THA:
	case OXM_OF_ARP_THA_W:
	{
		Mac48Address Mac;
		ofl_match_tlv* tlv = oxm_match_lookup (oxm_of, match);
		Mac.CopyFrom (tlv->value);
		return Mac;
	}
	default:
		NS_ABORT_MSG ("Invalid MAC field.");
	}

}

uint16_t
QosController::ExtractEthernetType (struct ofl_match* match){
	// Get Ethernet frame type
	uint16_t ethType; //16 bit perchè così dice OXM_OF_ETH_TYPE
	struct ofl_match_tlv *tlv = oxm_match_lookup (OXM_OF_ETH_TYPE, match);
	memcpy (&ethType, tlv->value, OXM_LENGTH (OXM_OF_ETH_TYPE));
	return ethType;
}

uint16_t
QosController::ExtractArpOperationCode(struct ofl_match* match){
	// Get ARP operation
	uint16_t arpOp;
	struct ofl_match_tlv *tlv = oxm_match_lookup (OXM_OF_ARP_OP, match);
	memcpy (&arpOp, tlv->value, OXM_LENGTH (OXM_OF_ARP_OP));
	return arpOp;
}

uint32_t
QosController::ExtractInPort(struct ofl_match* match){
	uint32_t inPort;
	struct ofl_match_tlv *tlv = oxm_match_lookup (OXM_OF_IN_PORT, match);
	memcpy (&inPort, tlv->value, OXM_LENGTH (OXM_OF_IN_PORT));
	return inPort;
}

uint8_t
QosController::ExtractIpProtocolID(struct ofl_match* match){
	uint8_t ipProtocolId; //8 bit perchè così dice OXM_OF_IP_PROTO
	struct ofl_match_tlv *tlv = oxm_match_lookup (OXM_OF_IP_PROTO,match);
	memcpy (&ipProtocolId, tlv->value, OXM_LENGTH (OXM_OF_IP_PROTO));
	return ipProtocolId;
}
uint16_t
QosController::ExtractUdpPort( uint32_t oxm_of , struct ofl_match* match){
	switch(oxm_of){
	case OXM_OF_UDP_SRC:
	case OXM_OF_UDP_DST:
	{
		uint16_t udp_port; //16 bit perchè così dice OXM_OF_UDP_*
		struct ofl_match_tlv *tlv = oxm_match_lookup (oxm_of, match);
		memcpy (&udp_port, tlv->value, OXM_LENGTH (oxm_of));
		return udp_port;
	}
	default:
		NS_ABORT_MSG ("Invalid UDP field.");
	}
}

Ptr<Packet>
QosController::CreateArpRequest (Mac48Address srcMac, Ipv4Address srcIp,
		Ipv4Address dstIp)
{
	NS_LOG_FUNCTION (this << srcMac << srcIp << dstIp);

	Ptr<Packet> packet = Create<Packet> ();

	// ARP header
	ArpHeader arp;
	arp.SetRequest (srcMac, srcIp, Mac48Address::GetBroadcast (), dstIp);
	packet->AddHeader (arp);

	// Ethernet header
	EthernetHeader eth (false);
	eth.SetSource (srcMac);
	eth.SetDestination (Mac48Address::GetBroadcast ());
	if (packet->GetSize () < 46)
	{
		uint8_t buffer[46];
		memset (buffer, 0, 46);
		Ptr<Packet> padd = Create<Packet> (buffer, 46 - packet->GetSize ());
		packet->AddAtEnd (padd);
	}
	eth.SetLengthType (ArpL3Protocol::PROT_NUMBER);
	packet->AddHeader (eth);

	// Ethernet trailer
	EthernetTrailer trailer;
	if (Node::ChecksumEnabled ())
	{
		trailer.EnableFcs (true);
	}
	trailer.CalcFcs (packet);
	packet->AddTrailer (trailer);

	return packet;
}

Ptr<Packet>
QosController::CreateArpReply (Mac48Address srcMac, Ipv4Address srcIp,
		Mac48Address dstMac, Ipv4Address dstIp)
{
	NS_LOG_FUNCTION (this << srcMac << srcIp << dstMac << dstIp);

	Ptr<Packet> packet = Create<Packet> ();

	// ARP header
	ArpHeader arp;
	arp.SetReply (srcMac, srcIp, dstMac, dstIp);
	packet->AddHeader (arp);

	// Ethernet header
	EthernetHeader eth (false);
	eth.SetSource (srcMac);
	eth.SetDestination (dstMac);
	if (packet->GetSize () < 46)
	{
		uint8_t buffer[46];
		memset (buffer, 0, 46);
		Ptr<Packet> padd = Create<Packet> (buffer, 46 - packet->GetSize ());
		packet->AddAtEnd (padd);
	}
	eth.SetLengthType (ArpL3Protocol::PROT_NUMBER);
	packet->AddHeader (eth);

	// Ethernet trailer
	EthernetTrailer trailer;
	if (Node::ChecksumEnabled ())
	{
		trailer.EnableFcs (true);
	}
	trailer.CalcFcs (packet);
	packet->AddTrailer (trailer);

	return packet;
}



void
QosController::shortActionOuputCreator(struct ofl_action_output* action, uint32_t outputSwitchPort, uint16_t lunghezzaMassimaDellaRisposta){
	action->header.type = OFPAT_OUTPUT;
	action->port = outputSwitchPort;
	action->max_len = lunghezzaMassimaDellaRisposta;
}

void
QosController::SaveArpEntry (Ipv4Address ipAddr, Mac48Address macAddr)
{
	std::pair<Ipv4Address, Mac48Address> entry (ipAddr, macAddr);
	std::pair <IpMacMap_t::iterator, bool> ret;
	ret = m_arpTable.insert (entry);
	if (ret.second == true)
	{
		NS_LOG_INFO ("New ARP entry: " << ipAddr << " - " << macAddr);
		return;
	}
}



Mac48Address
QosController::GetArpEntry (Ipv4Address ip)
{
	IpMacMap_t::iterator ret;
	ret = m_arpTable.find (ip);
	if (ret != m_arpTable.end ())
	{
		//std::cout << "MAC associato all' IpDest TROVATO" << std::endl;
		NS_LOG_INFO ("Found ARP entry: " << ip << " - " << ret->second);
		return ret->second;
	}
	NS_ABORT_MSG ("No ARP information for this IP.");

}

bool
QosController::ExistArpEntry (Ipv4Address ip)
{
	IpMacMap_t::iterator ret;
	ret = m_arpTable.find(ip);
	if(ret!=m_arpTable.end())
		return true;
	return false;
}

int
QosController::SaveSwitchEntry (uint64_t dpIdSwitch, Ptr<const RemoteSwitch> swtch)
{
	std::pair<uint64_t, Ptr<const RemoteSwitch>> entry (dpIdSwitch, swtch);
	std::pair <DpIdRemoteSwitch_t::iterator, bool> ret;
	ret = m_dpIdTable.insert (entry);
	if (ret.second == true)
	{
		NS_LOG_INFO ("New SwitchEntry entry: " << dpIdSwitch << " - " << swtch);
		return 1;
	}
	return 0;
}

bool
QosController::ExistSwitchEntry (uint64_t swtchDpId)
{
	DpIdRemoteSwitch_t::iterator ret;
	ret = m_dpIdTable.find(swtchDpId);
	if(ret!=m_dpIdTable.end())
		return true;
	return false;
}

int
QosController::SavePortForwardEntry (uint64_t from, uint64_t to, uint32_t port)
{
	std::pair<uint64_t, uint64_t> entrySwitchId (from, to);
	std::pair<std::pair<uint64_t, uint64_t>,uint32_t> entryPort (entrySwitchId, port);
	std::pair <PortForwardFromS1ToS2_t::iterator, bool> ret;

	ret = m_PortFrowardTable.insert (entryPort);
	if (ret.second == true)
	{
		std::cout<<"PortForwardEntry salvata-> "<< " fromSwitch: " <<from << " toSwitch: "<< to << " by port: " << port <<std::endl;

		NS_LOG_INFO ("Nuova Portforward entry-> "<< " fromSwitch: " <<from << " toSwitch: "<< to << " by port: " << port );
		return 1;
	}
	return 0;
}

uint32_t
QosController::ExistPortForwardEntry(Ptr<const RemoteSwitch> switchFrom, Ptr<const RemoteSwitch> switchTo){
	return ExistPortForwardEntry(switchFrom->GetDpId(),switchTo->GetDpId());
}

uint32_t
QosController::ExistPortForwardEntry(uint64_t from, uint64_t to){
	PortForwardFromS1ToS2_t::iterator ret;
	std::pair<uint64_t, uint64_t> entrySwitchId (from, to);
	ret = m_PortFrowardTable.find(entrySwitchId);
	if (ret != m_PortFrowardTable.end ())
	{
		std::cout<<"Just exist Port From: "<<from<< " To: "<<to<<std::endl;
		return true;
	}
	return false;
}


uint32_t
QosController::GetPortForwardEntry (Ptr<const RemoteSwitch> switchFrom, Ptr<const RemoteSwitch> switchTo){
	return GetPortForwardEntry(switchFrom->GetDpId(),switchTo->GetDpId());
}

uint32_t
QosController::GetPortForwardEntry (uint64_t from, uint64_t to)
{
	PortForwardFromS1ToS2_t::iterator ret;
	std::pair<uint64_t, uint64_t> entrySwitchId (from, to);
	ret = m_PortFrowardTable.find (entrySwitchId);
	std::cout<<"From: "<<from<< " To: "<<to<<std::endl;
	if (ret != m_PortFrowardTable.end ())
	{
		NS_LOG_INFO ("Found PortForward entry: " << from << " "<< to << " -> " << ret->second);
		return ret->second;
	}
	NS_ABORT_MSG ("No PortForward information for this from and to.");

}

void QosController::SaveIpDestEntry(Ipv4Address address, uint64_t swtchDpId){
	std::pair<Ipv4Address,uint64_t> entry (address,swtchDpId);
	std::pair<IpSwitchMap_t::iterator,bool> ret;
	ret = m_ipDestTable.insert (entry);
	if (ret.second == true)
	{
		NS_LOG_INFO ("New IpDest entry: " << address << " - " << swtchDpId);
		return;
	}
}

uint64_t
QosController::GetIpDestEntry(Ipv4Address address){
	IpSwitchMap_t::iterator itr;
	itr = m_ipDestTable.find(address);
	if(itr!=m_ipDestTable.end()){
		NS_LOG_INFO ("Found IpDestEntry entry: " << address << " - " << itr->second);
		return itr->second;
	}
	NS_ABORT_MSG ("No IpDestEntry information for this IP.");
}

void
QosController::SaveServiceEntry(Ipv4Address address, std::list<int> weightList){
	std::pair<Ipv4Address, std::list<int>> entry (address, weightList);
	std::pair<IpServiceMap_t::iterator,bool> ret;
	ret = m_IpServiceTable.insert(entry);
	if (ret.second == true)
	{
		return;
	}
}

bool
QosController::ExistServiceEntry(Ipv4Address address){
	IpServiceMap_t::iterator itr;
	itr = m_IpServiceTable.find(address);
	if(itr!=m_IpServiceTable.end()){
		return true;
	}
	return false;
}

std::list<int>
QosController::GetServiceEntry(Ipv4Address address){
	IpServiceMap_t::iterator itr;
	itr = m_IpServiceTable.find(address);
	if(itr!=m_IpServiceTable.end()){
		NS_LOG_INFO ("Found IpService entry: " << address);
		return itr->second;
	}
	NS_ABORT_MSG ("No IpDestEntry information for this IP.");
}

int
QosController::addFlowModToPathSwitch(std::list<int> path, Ipv4Address ipSrc, Ipv4Address ipDst){
	std::list<int>::iterator itFrom, itTo;
	itFrom = path.begin();
	itTo = path.begin();
	++itTo;//vai al secondo argomento
	uint32_t switchFromPort;

	while(itTo!=path.end()){



		switchFromPort = GetPortForwardEntry(*itFrom,*itTo);
		std::cout<<"FlowMod From: "<<*itFrom<<" To: "<<*itTo<<" ByPort: "<<switchFromPort<<std::endl;
		std::ostringstream flow;
		flow << "flow-mod table=0,cmd=add "
				//<<" eth_type="<<ethernetType
				//<<",ip_prot="<<ipProtocolNumber
				<<" eth_type=0x0800"
				<<",ip_src="<<ipSrc
				<<",ip_dst="<<ipDst
				<<" apply:output="<<switchFromPort;
		//<<" meter:1 apply:output="<<switchFromPort;//lo1
		DpctlExecute(GetRemoteSwitch(*itFrom),flow.str());
		++itFrom;
		++itTo;
	}
	return 1;
}



int
QosController::addFlowModToPathSwitch(std::list<int> path, Ipv4Address ipSrc, Ipv4Address ipDst, int weight){
	std::list<int>::iterator itFrom, itTo;
	itFrom = path.begin();
	itTo = path.begin();
	++itTo;//vai al secondo argomento
	uint32_t switchFromPort;

	while(itTo!=path.end()){
		switchFromPort = GetPortForwardEntry(*itFrom,*itTo);
		std::cout<<"FlowMod From: "<<*itFrom<<" To: "<<*itTo<<" ByPort: "<<switchFromPort<<std::endl;
		std::ostringstream flow;
		flow << "flow-mod table=0,cmd=add "
				//<<" eth_type="<<ethernetType
				//<<",ip_prot="<<ipProtocolNumber
				<<" eth_type=0x0800"
				<<",ip_src="<<ipSrc
				<<",ip_dst="<<ipDst
				<<" apply:output="<<switchFromPort;
		//<<" meter:1 apply:output="<<switchFromPort;//lo1
		DpctlExecute(GetRemoteSwitch(*itFrom),flow.str());
		++itFrom;
		++itTo;
	}
	return 1;
}


typedef struct {
	uint64_t fonte;
	std::list<std::pair<int,int>> lista;
} fonteDestPesata;

int
QosController::ServiceManagerIPbased(int** graph, int nNode, Ipv4Address ipSrc, Ipv4Address ipDst){
	std::list<int> weightPath;
	//Tipo di servizio, download/upload
	if(ExistServiceEntry(ipSrc))
		weightPath = GetServiceEntry(ipSrc);
	if(ExistServiceEntry(ipDst))
		weightPath = GetServiceEntry(ipDst);

	if(weightPath.size()>0){
		uint64_t vSwitchSrc, vSwitchDst;
		vSwitchSrc = GetIpDestEntry(ipSrc);
		vSwitchDst = GetIpDestEntry(ipDst);
		std::list<std::list<int>> listOfShortestPath;
		listOfShortestPath = YenKShortestPath(graph,nNode,vSwitchSrc,vSwitchDst,weightPath.size());

		std::map<int,std::list<std::pair<int,int>>> fonteDestWeight;

		std::list<int>::iterator weightPathIter = weightPath.begin();
		for(std::list<std::list<int>>::iterator itLoL = listOfShortestPath.begin(); itLoL != listOfShortestPath.end(); ++itLoL){
			std::list<int>::iterator itFrom = (*itLoL).begin();
			std::list<int>::iterator itTo = (*itLoL).begin();
			++itTo;
			while(itTo != (*itLoL).end()){

				std::map<int,std::list<std::pair<int,int>>>::iterator it = fonteDestWeight.find(*itFrom);

				std::pair<int,int> nuovaCoppia ((*itTo),(*weightPathIter));

				if(it == fonteDestWeight.end()){
					//Se non esiste la fonte, la inserisce ed inserisce il primo elemento
					std::list<std::pair<int,int>> nuovaLista {nuovaCoppia};
					std::pair<int,std::list<std::pair<int,int>>> entry ((*itFrom),nuovaLista);
					fonteDestWeight.insert(entry);
				}else{
					//Se la fonte esiste, deve prendere la lista associata alla fonte e aggiungervi un elemento nuovo
					int copyOfFonte = it->first;
					std::list<std::pair<int,int>> copyOfList = it->second;
					copyOfList.push_front(nuovaCoppia);
					std::pair<int,std::list<std::pair<int,int>>> entry (copyOfFonte,copyOfList);
					//Sovrascrive al dato precedentemente contenuto
					fonteDestWeight.erase(it);
					fonteDestWeight.insert(entry);
				}
				++itFrom;
				++itTo;
			}
			++weightPathIter;
		}


		std::map<int,std::list<std::pair<int,int>>>::iterator FDWiter;
		for(FDWiter = fonteDestWeight.begin(); FDWiter != fonteDestWeight.end(); ++FDWiter){
			std::ostringstream groupEntry;
			int fonteAttuale = (FDWiter->first);
			groupEntry << "group-mod cmd=add,type=sel,group="<<group_id;
			std::list<std::pair<int,int>> listaAttuale (FDWiter->second);
			for(std::list<std::pair<int,int>>::iterator iter = listaAttuale.begin(); iter != listaAttuale.end(); ++iter){

				groupEntry<< " weight=" << (*iter).second //second è il peso
						<< ",port=" << "any"
						<< ",group=" << "any"
						<< " output=" << GetPortForwardEntry(fonteAttuale,(*iter).first); //first è la destinazione
			}
			std::cout<<groupEntry.str()<<std::endl;
			DpctlExecute(FDWiter->first,groupEntry.str()); // first è lo switch
			DpctlExecute(FDWiter->first,"flow-mod cmd=add,table=0,prio=20 "
							"eth_type=0x0800,ip_proto=17,ip_src=10.1.2.1,ip_dst=10.1.3.2 write:group=1");
		}
	}else{

	}
	group_id++;
	return 1;
}

/*Backupt ServiceManager Funzionante circa fa fonte*/
/*
 std::list<int> weightPath;
	//Tipo di servizio, download/upload
	if(ExistServiceEntry(ipSrc))
		weightPath = GetServiceEntry(ipSrc);
	if(ExistServiceEntry(ipDst))
		weightPath = GetServiceEntry(ipDst);

	if(weightPath.size()>0){
		uint64_t vSwitchSrc, vSwitchDst;
		vSwitchSrc = GetIpDestEntry(ipSrc);
		vSwitchDst = GetIpDestEntry(ipDst);
		std::list<std::list<int>> listOfShortestPath;
		listOfShortestPath = YenKShortestPath(graph,nNode,vSwitchSrc,vSwitchDst,weightPath.size());

		std::list<int>::iterator weightPathIter = weightPath.begin();
		std::ostringstream groupEntry;
		groupEntry << "group-mod cmd=add,type=sel,group="<<group_id;
		for(std::list<std::list<int>>::iterator itr = listOfShortestPath.begin(); itr != listOfShortestPath.end(); ++itr){
			//Per ogni shortest path devo imporre la regola dei gruppi
			std::list<int>::iterator itrFrom = (*itr).begin();
			std::list<int>::iterator itrTo = (*itr).begin();
			++itrTo;

			//Creo multi regole per sel in base a quello che mi dice il weightPath
			groupEntry<< " weight=" << (*weightPathIter)
													  << ",port=" << "any"
													  << ",group=" << "any"
													  << " output=" << GetPortForwardEntry((*itrFrom),(*itrTo));
			++weightPathIter;
		}
		std::cout<<"lunghezza weightPath = "<< weightPath.size() <<std::endl;
		std::cout<<groupEntry.str()<<std::endl;
		DpctlExecute(vSwitchSrc,groupEntry.str());
		DpctlExecute(GetRemoteSwitch((*itrFrom)),"flow-mod cmd=add,table=0,prio=20 "
				"eth_type=0x0800,ip_proto=17,ip_src=10.1.2.1,ip_dst=10.1.3.2 write:group=1");

		group_id++;

	}else{

	}
	return 1;
 */









