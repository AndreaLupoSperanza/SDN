/*
 * quos-controller-backup.cc
 *
 *  Created on: 5 feb 2020
 *      Author: openflow
 */
/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2016 University of Campinas (Unicamp)
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Author:  Luciano Chaves <luciano@lrc.ic.unicamp.br>
 */

#define INF 99999

#include <ns3/network-module.h>
#include <ns3/internet-module.h>
#include "qos-controller.h"

NS_LOG_COMPONENT_DEFINE ("QosController");
NS_OBJECT_ENSURE_REGISTERED (QosController);

QosController::QosController ()
{
	NS_LOG_FUNCTION (this);
}

QosController::~QosController ()
{
	NS_LOG_FUNCTION (this);
}

void
QosController::DoDispose ()
{
	NS_LOG_FUNCTION (this);

	m_arpTable.clear ();
	OFSwitch13Controller::DoDispose ();
}

TypeId
QosController::GetTypeId (void)
{
	static TypeId tid = TypeId ("ns3::QosController")
    																																																										.SetParent<OFSwitch13Controller> ()
																																																											.SetGroupName ("OFSwitch13")
																																																											.AddConstructor<QosController> ()
																																																											.AddAttribute ("EnableMeter",
																																																													"Enable per-flow mettering.",
																																																													BooleanValue (false),
																																																													MakeBooleanAccessor (&QosController::m_meterEnable),
																																																													MakeBooleanChecker ())
																																																													.AddAttribute ("MeterRate",
																																																															"Per-flow meter rate.",
																																																															DataRateValue (DataRate ("256Kbps")),
																																																															MakeDataRateAccessor (&QosController::m_meterRate),
																																																															MakeDataRateChecker ())
																																																															.AddAttribute ("LinkAggregation",
																																																																	"Enable link aggregation.",
																																																																	BooleanValue (true),
																																																																	MakeBooleanAccessor (&QosController::m_linkAggregation),
																																																																	MakeBooleanChecker ())
																																																																	.AddAttribute ("ServerIpAddr",
																																																																			"Server IPv4 address.",
																																																																			AddressValue (Address (Ipv4Address ("10.1.1.1"))),
																																																																			MakeAddressAccessor (&QosController::m_serverIpAddress),
																																																																			MakeAddressChecker ())
																																																																			.AddAttribute ("ServerTcpPort",
																																																																					"Server TCP port.",
																																																																					UintegerValue (9),
																																																																					MakeUintegerAccessor (&QosController::m_serverTcpPort),
																																																																					MakeUintegerChecker<uint64_t> ())
																																																																					.AddAttribute ("ServerMacAddr",
																																																																							"Server MAC address.",
																																																																							AddressValue (Address (Mac48Address ("00:00:00:00:00:01"))),
																																																																							MakeAddressAccessor (&QosController::m_serverMacAddress),
																																																																							MakeAddressChecker ())
																																																																							;
	return tid;
}

void
QosController::SetWeight(std::string weight){
	InputWeight = weight;
}

void
QosController::HandshakeSuccessful (Ptr<const RemoteSwitch> swtch)
{
	NS_LOG_FUNCTION (this << swtch);
	std::cout<<"Vediamo "<< swtch->GetDpId() <<std::endl;
	/*
	if(swtch->GetDpId()==1){
		DpctlExecute(swtch,"flow-mod table=0,cmd=add eth_type=0x800,ip_proto=17,ip_src=10.1.2.2,ip_dst=10.1.3.1 apply:output=1");
	}
	if(swtch->GetDpId()==4){
		DpctlExecute(swtch,"flow-mod table=0,cmd=add eth_type=0x800,ip_proto=17,ip_src=10.1.2.2,ip_dst=10.1.3.1 apply:output=3");
	}
	 */
	//if(swtch->GetDpId()==1){
	//DpctlExecute(swtch,"meter-mod cmd=add,flags=1,meter=1 drop:rate=1000");//lo1...dscp_remark:rate=10,prec_level=8
	//}
	//DpctlExecute(swtch,"flow-mod table=0,cmd=add eth_type=0x800,ip_proto=17,ip_src=10.1.2.2,ip_dst=10.1.3.1,ip_dscp=8 apply:output=2");


	/*TEST METER TABLE*/

	if(swtch->GetDpId()==1){
		DpctlExecute(swtch,"stats-meter 1");
		DpctlExecute(swtch,"meter-features");
		DpctlExecute(swtch,"meter-config 1");
		/*
		DpctlExecute(swtch,"meter-mod cmd=add,meter=1,flags=1 dscp_remark:rate=10000");//,burst=20000 e dscp_remark:rate=1000,prec_level=1 --> 100Mbits = 100000 bit/s
		DpctlExecute(swtch,"meter-mod cmd=add,meter=2,flags=1 drop:rate=10000");

		struct ofl_meter_band_dscp_remark* meterModBands = (ofl_meter_band_dscp_remark*)xmalloc(sizeof(ofl_meter_band_dscp_remark));
		meterModBands->type=OFPMBT_DSCP_REMARK;
		meterModBands->rate=10000;
		meterModBands->prec_level=(-14);



		struct ofl_msg_meter_mod meterMod;
		meterMod.header.type=OFPT_METER_MOD;
		meterMod.command=OFPMC_ADD;
		meterMod.flags=OFPMF_KBPS; // impone kbps
		meterMod.meter_id=3;
		meterMod.bands=(ofl_meter_band_header**)&meterModBands;
		meterMod.meter_bands_num=1;

		SendToSwitch (swtch, (struct ofl_msg_header*)&meterMod, GetNextXid());
		 */
		/*FUNZIONANTE*/
		/*
		DpctlExecute(swtch,"flow-mod table=0,cmd=add eth_type=0x800,ip_proto=17,ip_src=10.1.2.2,ip_dst=10.1.3.1 apply:set_field=ip_dscp:4,output=1");//set_field=ip_dscp:32,
		 */
		/*FINE FUNZIONANTE*/
		DpctlExecute(swtch,"flow-mod table=0,cmd=add eth_type=0x800,ip_proto=17,ip_src=10.1.2.2,ip_dst=10.1.3.1 apply:output=1");

	}
	if(swtch->GetDpId()==3){
		DpctlExecute(swtch,"flow-mod table=0,cmd=add eth_type=0x800,ip_proto=17,ip_src=10.1.2.2,ip_dst=10.1.3.1 apply:output=3");
	}
	if(swtch->GetDpId()==4){
		/*PROVA FUNZIONANTE FLOW-SLICING-INTRASWITCH*/
		DpctlExecute(swtch,"flow-mod table=0,cmd=add eth_type=0x800,ip_proto=17,ip_src=10.1.2.2,ip_dst=10.1.3.1 apply:set_field=ip_dscp:4 goto:1");
		DpctlExecute(swtch,"meter-mod cmd=add,meter=1,flags=1 dscp_remark:rate=1000,prec_level=1");
		DpctlExecute(swtch,"flow-mod table=1,cmd=add eth_type=0x800,ip_proto=17,ip_src=10.1.2.2,ip_dst=10.1.3.1 meter:1 goto:2");
		DpctlExecute(swtch,"flow-mod table=2,cmd=add eth_type=0x800,ip_proto=17,ip_src=10.1.2.2,ip_dst=10.1.3.1,ip_dscp=4 apply:output=2");
		DpctlExecute(swtch,"flow-mod table=2,cmd=add eth_type=0x800,ip_proto=17,ip_src=10.1.2.2,ip_dst=10.1.3.1,ip_dscp=6 apply:output=3");
		/*FINE PROVA*/
		/*FUNZIONANTE*/
		/*
		DpctlExecute(swtch,"meter-mod cmd=add,meter=1,flags=1 dscp_remark:rate=1000,prec_level=1");
		DpctlExecute(swtch,"flow-mod table=0,cmd=add eth_type=0x800,ip_proto=17,ip_src=10.1.2.2,ip_dst=10.1.3.1 meter:1 goto:1");
		DpctlExecute(swtch,"flow-mod table=1,cmd=add eth_type=0x800,ip_proto=17,ip_src=10.1.2.2,ip_dst=10.1.3.1,ip_dscp=4 apply:output=2");
		DpctlExecute(swtch,"flow-mod table=1,cmd=add eth_type=0x800,ip_proto=17,ip_src=10.1.2.2,ip_dst=10.1.3.1,ip_dscp=6 apply:output=3");
		 */
		/*FINE FUNZIONANTE*/
	}

	/*FINE TEST METER TABLE*/

	ConfigureBorderSwitch_FUB(swtch);
	SendBarrierRequest (swtch); //Per tentare di fargli eseguire tutti i comandi ricevuti prima di questo e poi gli altri, ma non funziona



	if(!ExistSwitchEntry(swtch->GetDpId())){
		/*In caso un nuovo switch si collega al controller, il grafo che rappresenta la rete diventa obsoleto
		 *Vanno quindi resi nulli il grafo e la matrice dei cammini
		 *Rifatta l'esplorazione, rifatto il blocco delle porte della rete, e rigenerata la matrice dei cammini
		 */
		std::cout<<"Conosciuto: "<< swtch->GetDpId() <<std::endl;

		SaveSwitchEntry(swtch->GetDpId(),swtch);
		nSwitch++;

		firstNetworkExplorer=1;
		NetworkExplorerFunction();
	}
}


ofl_err
QosController::HandlePacketIn (
		struct ofl_msg_packet_in *msg, Ptr<const RemoteSwitch> swtch,
		uint32_t xid)
{
	NS_LOG_FUNCTION (this << swtch << xid);

	//std::cout << "inzio gestione packet in" << std::endl;
	char *msgStr =
			ofl_structs_match_to_string ((struct ofl_match_header*)msg->match, 0);
	NS_LOG_DEBUG ("Packet in match: " << msgStr);
	free (msgStr);

	if (msg->reason == OFPR_ACTION)
	{
		// Get Ethernet frame type
		uint16_t ethType = ExtractEthernetType((struct ofl_match*)msg->match);

		if (ethType == ArpL3Protocol::PROT_NUMBER)
		{

			if(firstNetworkExplorer==1){ //only the first packet-in enable the exploring
				std::cout<<"Prima esplorazione"<<std::endl;
				NetworkExplorerFunction();
				firstNetworkExplorer=2;
			}else if(firstNetworkExplorer==2){
				networkGrafe = GrafeGeneration(nSwitch);
				networkMatrixPath = floydWarshall(networkGrafe,nSwitch);
				firstNetworkExplorer = 0;
			}else{
				return HandleArpPacketIn (msg, swtch, xid);
			}
		}
		else if (ethType == Ipv4L3Protocol::PROT_NUMBER)
		{
			//std::cout << "è un pacchetto Ipv4L3Protocol" << std::endl;

			uint8_t ipProtocolId = ExtractIpProtocolID((struct ofl_match*)msg->match);
			//std::cout<<"id_protcol: "<< id_protocol<<std::endl;

			if(ipProtocolId == UdpL4Protocol::PROT_NUMBER){ //Sarà un pacchetto udp
				std::cout<<"UDP!!!!!"<<std::endl;

				uint16_t udp_dst_port= ExtractUdpPort(OXM_OF_UDP_DST,(struct ofl_match*)msg->match);;

				if(udp_dst_port == networkExplorerUdpPort){ //è un pacchetto di esplorazione di rete
					uint16_t udp_src_port = ExtractUdpPort(OXM_OF_UDP_SRC,(struct ofl_match*)msg->match);
					uint32_t inPort = ExtractInPort((struct ofl_match*)msg->match);

					std::cout<< "pacchetto explorer UDP da: "<< udp_src_port - networkExplorerUdpPort << " in port: "<< inPort << " dello switch: "<< swtch->GetDpId()<< std::endl;

					uint64_t fromSwitch = swtch->GetDpId();
					uint64_t toSwitch = udp_src_port - networkExplorerUdpPort;
					uint32_t portUseInFrom = inPort;

					SavePortForwardEntry(fromSwitch,toSwitch,portUseInFrom);
					portSwitchConfiguration(fromSwitch,portUseInFrom);
				}else{
					//Gestisci altri pacchetti udp
					std::cout<< "pacchetto generico UDP (NON EXPLORER)" << std::endl;
				}
			}else if(ipProtocolId == TcpL4Protocol::PROT_NUMBER){
				return HandleConnectionRequest (msg, swtch, xid);
			}
		}
		else
		{
			std::cout<< "altro tipo di pacchetto" << std::endl;
		}
	}

	// All handlers must free the message when everything is ok
	ofl_msg_free ((struct ofl_msg_header*)msg, 0);
	return 0;
}



void
QosController::ConfigureBorderSwitch (Ptr<const RemoteSwitch> swtch)
{
	NS_LOG_FUNCTION (this << swtch);
}

void
QosController::ConfigureAggregationSwitch (Ptr<const RemoteSwitch> swtch)
{
	NS_LOG_FUNCTION (this << swtch);
}

void
QosController::ConfigureBorderSwitch_FUB (Ptr<const RemoteSwitch> swtch)
{
	std::cout << "configureBorderSwitch_FUB" << std::endl;
	NS_LOG_FUNCTION (this << swtch);

	// For packet-in messages, send only the first 128 bytes to the controller
	DpctlExecute (swtch, "set-config miss=128");
	/*----------------------------------------------------------------------*/
	//CONCENTRATI QUI
	//std::cout << "Provo ad impostare la regola" << std::endl;

	// Redirect ARP requests to the controller
	DpctlExecute (swtch, "flow-mod cmd=add,table=0,prio=20 "
			"eth_type=0x0806,arp_op=1 apply:output=ctrl");

	//Redirect ARP Reply from any Host to Controller
	DpctlExecute (swtch, "flow-mod cmd=add,table=0,prio=20 "
			"eth_type=0x0806,arp_op=2 apply:output=ctrl");

	//Network explorer packet redirect
	DpctlExecute(swtch,"flow-mod cmd=add,table=0,prio=20 "
			"eth_type=0x0800,ip_proto=17,udp_dst=11000 apply:output=ctrl");

	DpctlExecute(swtch,"flow-mod cmd=add,table=0,prio=1 "
			"eth_type=0x0800 apply:output=ctrl");
	//std::cout << "Regola Impostata" << std::endl;
}



void
QosController::ConfigureAggregationSwitch_FUB (Ptr<const RemoteSwitch> swtch)
{
	NS_LOG_FUNCTION (this << swtch);

}

ofl_err
QosController::HandleArpPacketIn (
		struct ofl_msg_packet_in *msg, Ptr<const RemoteSwitch> swtch,
		uint32_t xid)
{
	NS_LOG_FUNCTION (this << swtch << xid);
	//std::cout << "HandlerArpPacket" << std::endl;

	Ipv4Address serverIp = Ipv4Address::ConvertFrom (m_serverIpAddress);
	Mac48Address serverMac = Mac48Address::ConvertFrom (m_serverMacAddress);

	// Get ARP operation
	uint16_t arpOp = ExtractArpOperationCode((struct ofl_match*)msg->match);

	// Get input port
	uint32_t inPort = ExtractInPort((struct ofl_match*)msg->match);

	// Get source and target IP address
	Ipv4Address srcIp, dstIp;
	srcIp = ExtractIpv4Address (OXM_OF_ARP_SPA, (struct ofl_match*)msg->match);
	dstIp = ExtractIpv4Address (OXM_OF_ARP_TPA, (struct ofl_match*)msg->match);

	// Get Source MAC address
	Mac48Address srcMac = ExtractMacAddress(OXM_OF_ARP_SHA,(struct ofl_match*)msg->match);
	//Save, if not exist already, ArpEntry
	SaveArpEntry(srcIp,srcMac);

	//Save, if not exist already, IpDestEntry
	SaveIpDestEntry(srcIp,swtch->GetDpId());

	//Generate ad IP based flow to the new entry, to redirect the destination traffic
	std::ostringstream flowDest;
	flowDest << "flow-mod table=0,cmd=add eth_type=0x800,ip_dst="<<srcIp<<" apply:output="<<inPort;
	DpctlExecute(swtch,flowDest.str());

	// Check for ARP request
	if (arpOp == ArpHeader::ARP_TYPE_REQUEST)
	{
		uint8_t replyData[64];

		if(ExistArpEntry(dstIp)){// In caso di ArpEntry presente, mi è stato chiesto il MAC di un host che conosco
			/*
			uint64_t srcSwitchDpId, dstSwitchDpId;
			srcSwitchDpId = swtch->GetDpId();
			dstSwitchDpId = GetIpDestEntry(dstIp);
			std::list<int> path = extractPath(networkMatrixPath,nSwitch,srcSwitchDpId,dstSwitchDpId);
			showElementList(path);
			setFlowModToPathSwitch(path,srcIp,dstIp);
			 */
			Mac48Address dstMac = GetArpEntry(dstIp);
			Ptr<Packet> pkt = CreateArpReply(dstMac,dstIp,srcMac,srcIp);
			NS_ASSERT_MSG(pkt->GetSize() == 64, "Invalid packet size.");
			pkt->CopyData(replyData,64);

			struct ofl_action_output *action =
					(struct ofl_action_output*)xmalloc (sizeof (struct ofl_action_output));

			this->shortActionOuputCreator(action, OFPP_IN_PORT, 0);//rimandalo alla porta di provenienza del messaggio che non hai saputo gestire

			struct ofl_msg_packet_out reply;
			reply.header.type = OFPT_PACKET_OUT;
			reply.buffer_id = OFP_NO_BUFFER;
			reply.in_port = inPort;
			reply.data_length = 64;
			reply.data = &replyData[0];
			reply.actions_num = 1;
			reply.actions = (struct ofl_action_header**)&action;

			SendToSwitch (swtch, (struct ofl_msg_header*)&reply, xid);
			free (action);

		}else{//In caso di ArpEntry non trovata, ossia, mi è stato chiesto il MAC di un host che non conosco
			//std::cout << "ArpEntry NON trovata, vado in ricerca" <<std::endl;

			Ptr<Packet> pkt = CreateArpRequest(serverMac, serverIp, dstIp);
			NS_ASSERT_MSG(pkt->GetSize() == 64, "Invalid packet size.");
			pkt->CopyData(replyData,64);//copia pkt in replydata che ha una lunghezza di 64 byte

			DpIdRemoteSwitch_t::iterator itr;
			for(itr = m_dpIdTable.begin(); itr != m_dpIdTable.end(); ++itr){

				struct ofl_action_output *action =
						(struct ofl_action_output*)xmalloc (sizeof (struct ofl_action_output));
				this->shortActionOuputCreator(action, OFPP_FLOOD, 0);

				// Send the ARP Reply within an OpenFlow PacketOut message
				struct ofl_msg_packet_out reply;
				reply.header.type = OFPT_PACKET_OUT;
				reply.buffer_id = OFP_NO_BUFFER;
				reply.in_port = OFPP_CONTROLLER;//da chi proviene il messaggio packet_out
				reply.data_length = 64;
				reply.data = &replyData[0];
				reply.actions_num = 1;
				reply.actions = (struct ofl_action_header**)&action;

				SendToSwitch(itr->second, (struct ofl_msg_header*)&reply, xid);
			}
		}
	}else{
		//std::cout<<"Ho ricevuto un reply"<<std::endl;
	}
	// All handlers must free the message when everything is ok
	ofl_msg_free ((struct ofl_msg_header*)msg, 0);
	//std::cout<< "fine gestione arp packet" << std::endl;
	return 0;
}

ofl_err
QosController::HandleConnectionRequest (
		struct ofl_msg_packet_in *msg, Ptr<const RemoteSwitch> swtch,
		uint32_t xid)
{
	NS_LOG_FUNCTION (this << swtch << xid);

	static uint32_t connectionCounter = 0;
	connectionCounter++;

	struct ofl_match_tlv *tlv;
	Ipv4Address serverIp = Ipv4Address::ConvertFrom (m_serverIpAddress);
	Mac48Address serverMac = Mac48Address::ConvertFrom (m_serverMacAddress);

	// Get input port
	uint32_t inPort = ExtractInPort((struct ofl_match*)msg->match);

	// Get Source MAC address
	Mac48Address srcMac = ExtractMacAddress(OXM_OF_ETH_SRC,(struct ofl_match*)msg->match);

	// Get source and destination IP address
	Ipv4Address srcIp, dstIp;
	srcIp = ExtractIpv4Address (OXM_OF_IPV4_SRC, (struct ofl_match*)msg->match);
	dstIp = ExtractIpv4Address (OXM_OF_IPV4_DST, (struct ofl_match*)msg->match);

	// Get source and destination TCP ports
	uint16_t srcPort, dstPort;
	tlv = oxm_match_lookup (OXM_OF_TCP_SRC, (struct ofl_match*)msg->match);
	memcpy (&srcPort, tlv->value, OXM_LENGTH (OXM_OF_TCP_SRC));
	tlv = oxm_match_lookup (OXM_OF_TCP_DST, (struct ofl_match*)msg->match);
	memcpy (&dstPort, tlv->value, OXM_LENGTH (OXM_OF_TCP_DST));

	// Create an ARP request for further address resolution
	SaveArpEntry (srcIp, srcMac);
	uint8_t replyData[64];
	Ptr<Packet> pkt = CreateArpRequest (serverMac, serverIp, srcIp);
	NS_ASSERT_MSG (pkt->GetSize () == 64, "Invalid packet size.");
	pkt->CopyData (replyData, 64);

	struct ofl_action_output *arpAction =
			(struct ofl_action_output*)xmalloc (sizeof (struct ofl_action_output));
	arpAction->header.type = OFPAT_OUTPUT;
	arpAction->port = OFPP_IN_PORT;
	arpAction->max_len = 0;

	// Send the ARP request within an OpenFlow PacketOut message
	struct ofl_msg_packet_out arpRequest;
	arpRequest.header.type = OFPT_PACKET_OUT;
	arpRequest.buffer_id = OFP_NO_BUFFER;
	arpRequest.in_port = inPort;
	arpRequest.data_length = 64;
	arpRequest.data = &replyData[0];
	arpRequest.actions_num = 1;
	arpRequest.actions = (struct ofl_action_header**)&arpAction;

	SendToSwitch (swtch, (struct ofl_msg_header*)&arpRequest, 0);
	free (arpAction);

	// Check for valid service connection request
	NS_ASSERT_MSG (dstIp.IsEqual (serverIp) && dstPort == m_serverTcpPort,
			"Invalid IP address / TCP port.");

	// Select an internal server to handle this connection
	uint16_t serverNumber = 1 + (connectionCounter % 2);
	NS_LOG_INFO ("Connection " << connectionCounter <<
			" redirected to server " << serverNumber);

	// If enable, install the metter entry for this connection
	if (m_meterEnable)
	{
		std::ostringstream meterCmd;
		meterCmd << "meter-mod cmd=add,flags=1,meter=" << connectionCounter
				<< " drop:rate=" << m_meterRate.GetBitRate () / 1000;
		DpctlExecute (swtch, meterCmd.str ());
	}

	// Install the flow entry for this TCP connection
	std::ostringstream flowCmd;
	flowCmd << "flow-mod cmd=add,table=0,prio=1000 eth_type=0x0800,ip_proto=6"
			<< ",ip_src=" << srcIp
			<< "ip_dst=" << m_serverIpAddress
			<< ",tcp_dst=" << m_serverTcpPort
			<< ",tcp_src=" << srcPort;
	if (m_meterEnable)
	{
		flowCmd << " meter:" << connectionCounter;
	}
	flowCmd << " write:group=" << serverNumber;
	DpctlExecute (swtch, flowCmd.str ());

	// Create group action with server number
	struct ofl_action_group *action =
			(struct ofl_action_group*)xmalloc (sizeof (struct ofl_action_group));
	action->header.type = OFPAT_GROUP;
	action->group_id = serverNumber;

	// Send the packet out to the switch.
	struct ofl_msg_packet_out reply;
	reply.header.type = OFPT_PACKET_OUT;
	reply.buffer_id = msg->buffer_id;
	reply.in_port = inPort;
	reply.actions_num = 1;
	reply.actions = (struct ofl_action_header**)&action;
	reply.data_length = 0;
	reply.data = 0;
	if (msg->buffer_id == NO_BUFFER)
	{
		// No packet buffer. Send data back to switch
		reply.data_length = msg->data_length;
		reply.data = msg->data;
	}

	SendToSwitch (swtch, (struct ofl_msg_header*)&reply, xid);
	free (action);

	// All handlers must free the message when everything is ok
	ofl_msg_free ((struct ofl_msg_header*)msg, 0);
	return 0;
}
/***************************************************************************/

void
QosController::NetworkExplorerFunction(){
	std::cout<<"NetworkExplorerFunction"<<std::endl;
	DpIdRemoteSwitch_t::iterator itr;
	for (itr = m_dpIdTable.begin(); itr != m_dpIdTable.end(); ++itr){
		std::cout<<"Per: "<< itr->second->GetDpId()<< std::endl;
		switchNetworkExplore(itr->second);
	}
}

void
QosController::switchNetworkExplore(Ptr<const RemoteSwitch> swtch){

	//std::cout<< "Inizio Network Explorer"<< std::endl;
	uint8_t pktExplorer[64];

	Ptr<Packet> pkt = CreateUdpExplorerPacket(swtch->GetDpId());

	pkt->CopyData(pktExplorer,64);

	struct ofl_action_output *action =
			(struct ofl_action_output*)xmalloc (sizeof (struct ofl_action_output));

	shortActionOuputCreator(action, OFPP_FLOOD ,0);

	struct ofl_msg_packet_out explorer;
	explorer.header.type=OFPT_PACKET_OUT;
	explorer.buffer_id=OFP_NO_BUFFER;
	explorer.in_port=OFPP_CONTROLLER;
	explorer.actions=(struct ofl_action_header**)&action;
	explorer.actions_num=1;
	explorer.data=&pktExplorer[0];
	explorer.data_length=64;

	SendToSwitch(swtch,(struct ofl_msg_header*)&explorer,GetNextXid());
}


Ptr<Packet>
QosController::CreateUdpExplorerPacket(uint64_t fromSwitchId){
	//Ipv4Address serverIp = Ipv4Address::ConvertFrom (m_serverIpAddress);
	//Mac48Address serverMac = Mac48Address::ConvertFrom (m_serverMacAddress);

	//std::cout<< "Creo packetto UDP"<< std::endl;
	//uint8_t * hello;
	//uint8_t fromSwitchIdData = (uint8_t)fromSwitchId;
	//uint32_t helloSize=24;
	//hello = (uint8_t*)calloc(helloSize,sizeof(uint8_t));
	//uint8_t  hello[24] = "ciao";

	//reinterpret_cast<const uint8_t*> ("hello"), 5
	//Ptr<Packet> pktU = Create<Packet>(hello,helloSize);
	Ptr<Packet> pktU = Create<Packet>();

	UdpHeader udpH;
	udpH.SetSourcePort(networkExplorerUdpPort+fromSwitchId);
	udpH.SetDestinationPort(networkExplorerUdpPort);
	udpH.EnableChecksums();
	Ipv4Address src="10.1.1.1";
	Ipv4Address dst="10.1.1.1";
	udpH.InitializeChecksum(src,dst,UdpL4Protocol::PROT_NUMBER);
	Buffer buffer;
	//buffer.Serialize(hello,helloSize);

	pktU->AddHeader(udpH);

	Ipv4Header ipv4H;
	ipv4H.SetSource("10.1.1.1");
	ipv4H.SetDestination("10.1.1.1");
	ipv4H.SetTtl(64);
	ipv4H.SetDontFragment();
	ipv4H.SetProtocol(UdpL4Protocol::PROT_NUMBER);
	ipv4H.SetPayloadSize(UdpL4Protocol::PROT_NUMBER);

	pktU->AddHeader(ipv4H);

	// Ethernet header
	EthernetHeader eth (false);
	eth.SetSource ("00:00:00:90:01:01");
	eth.SetDestination ("00:00:00:90:02:01");
	if (pktU->GetSize () < 46)
	{
		uint8_t buffer[46];
		memset (buffer, 0, 46);
		Ptr<Packet> padd = Create<Packet> (buffer, 46 - pktU->GetSize ());
		pktU->AddAtEnd (padd);
	}
	eth.SetLengthType (Ipv4L3Protocol::PROT_NUMBER);
	pktU->AddHeader (eth);

	// Ethernet trailer
	EthernetTrailer trailer;
	if (Node::ChecksumEnabled ())
	{
		trailer.EnableFcs (true);
	}
	trailer.CalcFcs (pktU);
	pktU->AddTrailer (trailer);

	return pktU;
}


void
QosController::portSwitchConfiguration(uint64_t switchDpId, uint32_t port){
	portSwitchConfiguration(GetRemoteSwitch(switchDpId),port);
}

void
QosController::portSwitchConfiguration(Ptr<const RemoteSwitch> swtch, uint32_t port){

	struct ofl_msg_port_mod pkt;
	pkt.header.type=OFPT_PORT_MOD;
	pkt.port_no=port;
	pkt.config=OFPPC_NO_FWD;
	pkt.mask=OFPPC_NO_FWD;
	//pkt.advertise=;

	std::cout << "inviato il blocco" << std::endl;

	SendToSwitch (swtch, (struct ofl_msg_header*)&pkt, GetNextXid());
}

/*******************************************/

int **
QosController::GrafeGeneration(int nSwitch){
	int** grafe = new int*[nSwitch];
	for (int i = 0; i < nSwitch; ++i){
		grafe[i] = new int[nSwitch];
		for(int j = 0; j < nSwitch; ++j){
			grafe[i][j]=INF;
		}
	}
	std::cout<<"grafo inizializzato"<<std::endl;
	PortForwardFromS1ToS2_t::iterator itr;
	for(itr = m_PortFrowardTable.begin(); itr != m_PortFrowardTable.end(); ++itr){
		std::cout<<"itr"<<std::endl;
		grafe[itr->first.first-1][itr->first.second-1]=1;
	}
	std::cout<<"grafo scritto"<<std::endl;
	for(int i=0; i<nSwitch; i++){
		for(int j=0; j<nSwitch; j++){
			std::cout<<grafe[i][j]<<" ";
		}
		std::cout<<std::endl;
	}
	std::cout<<"grafo stampato"<<std::endl;
	return grafe;
}

/*****************************************************/
void printSolution(int** pred, const int V)
{
	std::cout<<"The following matrix shows the path"
			" between every pair of vertices "<<std::endl;
	for (int i = 0; i < V; i++)
	{
		for (int j = 0; j < V; j++)
		{
			if (pred[i][j] == INF)
				std::cout<<"INF"<<"     ";
			else
				std::cout<<pred[i][j]<<"     ";
		}
		std::cout<<std::endl;
	}
}

int **
QosController::floydWarshall (int** graph, const int V)
{

	int i, j, k;

	int** dist = new int*[V];
	int** next = new int*[V];
	for (int i = 0; i < V; ++i){
		dist[i] = new int[V];
		next[i] = new int[V];
		for(int j = 0; j < V; ++j){
			dist[i][j]=0;
			next[i][j]=0;
		}
	}
	for (i = 0; i < V; i++){
		for (j = 0; j < V; j++){
			dist[i][j] = graph[i][j];
			next[i][j] = j;
		}
	}
	for(i = 0; i< V; i++){
		dist[i][i]=0;
		next[i][i]=i;
	}
	for (k = 0; k < V; k++)
	{
		for (i = 0; i < V; i++)
		{
			for (j = 0; j < V; j++)
			{
				if (dist[i][j] > dist[i][k] + dist[k][j]){
					dist[i][j] = dist[i][k] + dist[k][j];
					next[i][j] = next[i][k];
				}
			}
		}
	}
	printSolution(next, V);
	return next;
}



std::list<int>
QosController::extractPath(int ** graph, const int V, Ptr<const RemoteSwitch> fromSwtch, Ptr<const RemoteSwitch> toSwtch){
	return extractPath(graph,V,fromSwtch->GetDpId(),toSwtch->GetDpId());
}

std::list<int>
QosController::extractPath(int ** graph, const int V, int from, int to){
	from--;
	to--;
	std::list<int> pathList;
	std::list<int>::iterator it;
	it = pathList.begin();

	std::cout<<"Cammino: "<<from<<std::endl;

	std::cout<<"Nodo: "<<from+1<<std::endl;
	pathList.insert(it,from+1);
	while(from!=to){
		std::cout<<"Nodo: "<< graph[from][to]+1<<std::endl;
		pathList.insert(it,graph[from][to]+1);
		from=graph[from][to];
	}
	return pathList;
}

void
QosController::showElementList(std::list<int> list){
	std::cout<<"showElementList"<<std::endl;
	std::list<int>::iterator it;
	for(it = list.begin(); it!=list.end(); ++it){
		std::cout<<" elemContain: "<< *it<< std::endl;
	}
}

/*****************************************************/
Ipv4Address
QosController::ExtractIpv4Address (uint32_t oxm_of, struct ofl_match* match)
{
	switch (oxm_of)
	{
	case OXM_OF_ARP_SPA:
	case OXM_OF_ARP_TPA:
	case OXM_OF_IPV4_DST:
	case OXM_OF_IPV4_SRC:
	{
		uint32_t ip;
		int size = OXM_LENGTH (oxm_of);
		struct ofl_match_tlv *tlv = oxm_match_lookup (oxm_of, match);
		memcpy (&ip, tlv->value, size);
		return Ipv4Address (ntohl (ip));
	}
	default:
		NS_ABORT_MSG ("Invalid IP field.");
	}
}
Mac48Address
QosController::ExtractMacAddress (uint32_t oxm_of, struct ofl_match* match){
	switch(oxm_of){
	case OXM_OF_ARP_SHA:
	case OXM_OF_ARP_SHA_W:
	case OXM_OF_ARP_THA:
	case OXM_OF_ARP_THA_W:
	{
		Mac48Address Mac;
		ofl_match_tlv* tlv = oxm_match_lookup (oxm_of, match);
		Mac.CopyFrom (tlv->value);
		return Mac;
	}
	default:
		NS_ABORT_MSG ("Invalid MAC field.");
	}

}

uint16_t
QosController::ExtractEthernetType (struct ofl_match* match){
	// Get Ethernet frame type
	uint16_t ethType; //16 bit perchè così dice OXM_OF_ETH_TYPE
	struct ofl_match_tlv *tlv = oxm_match_lookup (OXM_OF_ETH_TYPE, match);
	memcpy (&ethType, tlv->value, OXM_LENGTH (OXM_OF_ETH_TYPE));
	return ethType;
}

uint16_t
QosController::ExtractArpOperationCode(struct ofl_match* match){
	// Get ARP operation
	uint16_t arpOp;
	struct ofl_match_tlv *tlv = oxm_match_lookup (OXM_OF_ARP_OP, match);
	memcpy (&arpOp, tlv->value, OXM_LENGTH (OXM_OF_ARP_OP));
	return arpOp;
}

uint32_t
QosController::ExtractInPort(struct ofl_match* match){
	uint32_t inPort;
	struct ofl_match_tlv *tlv = oxm_match_lookup (OXM_OF_IN_PORT, match);
	memcpy (&inPort, tlv->value, OXM_LENGTH (OXM_OF_IN_PORT));
	return inPort;
}

uint8_t
QosController::ExtractIpProtocolID(struct ofl_match* match){
	uint8_t ipProtocolId; //8 bit perchè così dice OXM_OF_IP_PROTO
	struct ofl_match_tlv *tlv = oxm_match_lookup (OXM_OF_IP_PROTO,match);
	memcpy (&ipProtocolId, tlv->value, OXM_LENGTH (OXM_OF_IP_PROTO));
	return ipProtocolId;
}
uint16_t
QosController::ExtractUdpPort( uint32_t oxm_of , struct ofl_match* match){
	switch(oxm_of){
	case OXM_OF_UDP_SRC:
	case OXM_OF_UDP_DST:
	{
		uint16_t udp_port; //16 bit perchè così dice OXM_OF_UDP_*
		struct ofl_match_tlv *tlv = oxm_match_lookup (oxm_of, match);
		memcpy (&udp_port, tlv->value, OXM_LENGTH (oxm_of));
		return udp_port;
	}
	default:
		NS_ABORT_MSG ("Invalid UDP field.");
	}
}

Ptr<Packet>
QosController::CreateArpRequest (Mac48Address srcMac, Ipv4Address srcIp,
		Ipv4Address dstIp)
{
	NS_LOG_FUNCTION (this << srcMac << srcIp << dstIp);

	Ptr<Packet> packet = Create<Packet> ();

	// ARP header
	ArpHeader arp;
	arp.SetRequest (srcMac, srcIp, Mac48Address::GetBroadcast (), dstIp);
	packet->AddHeader (arp);

	// Ethernet header
	EthernetHeader eth (false);
	eth.SetSource (srcMac);
	eth.SetDestination (Mac48Address::GetBroadcast ());
	if (packet->GetSize () < 46)
	{
		uint8_t buffer[46];
		memset (buffer, 0, 46);
		Ptr<Packet> padd = Create<Packet> (buffer, 46 - packet->GetSize ());
		packet->AddAtEnd (padd);
	}
	eth.SetLengthType (ArpL3Protocol::PROT_NUMBER);
	packet->AddHeader (eth);

	// Ethernet trailer
	EthernetTrailer trailer;
	if (Node::ChecksumEnabled ())
	{
		trailer.EnableFcs (true);
	}
	trailer.CalcFcs (packet);
	packet->AddTrailer (trailer);

	return packet;
}

Ptr<Packet>
QosController::CreateArpReply (Mac48Address srcMac, Ipv4Address srcIp,
		Mac48Address dstMac, Ipv4Address dstIp)
{
	NS_LOG_FUNCTION (this << srcMac << srcIp << dstMac << dstIp);

	Ptr<Packet> packet = Create<Packet> ();

	// ARP header
	ArpHeader arp;
	arp.SetReply (srcMac, srcIp, dstMac, dstIp);
	packet->AddHeader (arp);

	// Ethernet header
	EthernetHeader eth (false);
	eth.SetSource (srcMac);
	eth.SetDestination (dstMac);
	if (packet->GetSize () < 46)
	{
		uint8_t buffer[46];
		memset (buffer, 0, 46);
		Ptr<Packet> padd = Create<Packet> (buffer, 46 - packet->GetSize ());
		packet->AddAtEnd (padd);
	}
	eth.SetLengthType (ArpL3Protocol::PROT_NUMBER);
	packet->AddHeader (eth);

	// Ethernet trailer
	EthernetTrailer trailer;
	if (Node::ChecksumEnabled ())
	{
		trailer.EnableFcs (true);
	}
	trailer.CalcFcs (packet);
	packet->AddTrailer (trailer);

	return packet;
}



void
QosController::shortActionOuputCreator(struct ofl_action_output* action, uint32_t outputSwitchPort, uint16_t lunghezzaMassimaDellaRisposta){
	action->header.type = OFPAT_OUTPUT;
	action->port = outputSwitchPort;
	action->max_len = lunghezzaMassimaDellaRisposta;
}

void
QosController::SaveArpEntry (Ipv4Address ipAddr, Mac48Address macAddr)
{
	std::pair<Ipv4Address, Mac48Address> entry (ipAddr, macAddr);
	std::pair <IpMacMap_t::iterator, bool> ret;
	ret = m_arpTable.insert (entry);
	if (ret.second == true)
	{
		NS_LOG_INFO ("New ARP entry: " << ipAddr << " - " << macAddr);
		return;
	}
}



Mac48Address
QosController::GetArpEntry (Ipv4Address ip)
{
	IpMacMap_t::iterator ret;
	ret = m_arpTable.find (ip);
	if (ret != m_arpTable.end ())
	{
		//std::cout << "MAC associato all' IpDest TROVATO" << std::endl;
		NS_LOG_INFO ("Found ARP entry: " << ip << " - " << ret->second);
		return ret->second;
	}
	NS_ABORT_MSG ("No ARP information for this IP.");

}

bool
QosController::ExistArpEntry (Ipv4Address ip)
{
	IpMacMap_t::iterator ret;
	ret = m_arpTable.find(ip);
	if(ret!=m_arpTable.end())
		return true;
	return false;
}

int
QosController::SaveSwitchEntry (uint64_t dpIdSwitch, Ptr<const RemoteSwitch> swtch)
{
	std::pair<uint64_t, Ptr<const RemoteSwitch>> entry (dpIdSwitch, swtch);
	std::pair <DpIdRemoteSwitch_t::iterator, bool> ret;
	ret = m_dpIdTable.insert (entry);
	if (ret.second == true)
	{
		NS_LOG_INFO ("New SwitchEntry entry: " << dpIdSwitch << " - " << swtch);
		return 1;
	}
	return 0;
}

bool
QosController::ExistSwitchEntry (uint64_t swtchDpId)
{
	DpIdRemoteSwitch_t::iterator ret;
	ret = m_dpIdTable.find(swtchDpId);
	if(ret!=m_dpIdTable.end())
		return true;
	return false;
}

int
QosController::SavePortForwardEntry (uint64_t from, uint64_t to, uint32_t port)
{
	std::pair<uint64_t, uint64_t> entrySwitchId (from, to);
	std::pair<std::pair<uint64_t, uint64_t>,uint32_t> entryPort (entrySwitchId, port);
	std::pair <PortForwardFromS1ToS2_t::iterator, bool> ret;

	ret = m_PortFrowardTable.insert (entryPort);
	if (ret.second == true)
	{
		std::cout<<"PortForwardEntry salvata-> "<< " fromSwitch: " <<from << " toSwitch: "<< to << " by port: " << port <<std::endl;

		NS_LOG_INFO ("Nuova Portforward entry-> "<< " fromSwitch: " <<from << " toSwitch: "<< to << " by port: " << port );
		return 1;
	}
	return 0;
}

uint32_t
QosController::GetPortForwardEntry (Ptr<const RemoteSwitch> switchFrom, Ptr<const RemoteSwitch> switchTo){
	return GetPortForwardEntry(switchFrom->GetDpId(),switchTo->GetDpId());
}

uint32_t
QosController::GetPortForwardEntry (uint64_t from, uint64_t to)
{
	PortForwardFromS1ToS2_t::iterator ret;
	std::pair<uint64_t, uint64_t> entrySwitchId (from, to);
	ret = m_PortFrowardTable.find (entrySwitchId);
	std::cout<<"From: "<<from<< " To: "<<to<<std::endl;
	if (ret != m_PortFrowardTable.end ())
	{
		NS_LOG_INFO ("Found PortForward entry: " << from << " "<< to << " -> " << ret->second);
		return ret->second;
	}
	NS_ABORT_MSG ("No PortForward information for this from and to.");

}

void QosController::SaveIpDestEntry(Ipv4Address address, uint64_t swtchDpId){
	std::pair<Ipv4Address,uint64_t> entry (address,swtchDpId);
	std::pair<IpSwitchMap_t::iterator,bool> ret;
	ret = m_ipDestTable.insert (entry);
	if (ret.second == true)
	{
		NS_LOG_INFO ("New IpDest entry: " << address << " - " << swtchDpId);
		return;
	}
}

uint64_t
QosController::GetIpDestEntry(Ipv4Address address){
	IpSwitchMap_t::iterator itr;
	itr = m_ipDestTable.find(address);
	if(itr!=m_ipDestTable.end()){
		NS_LOG_INFO ("Found IpDestEntry entry: " << address << " - " << itr->second);
		return itr->second;
	}
	NS_ABORT_MSG ("No IpDestEntry information for this IP.");
}

void
QosController::setFlowModToPathSwitch(std::list<int> path, Ipv4Address ipSrc, Ipv4Address ipDst){
	std::list<int>::iterator itFrom, itTo;
	itFrom = path.begin();
	itTo = path.begin();
	++itTo;//vai al secondo argomento
	uint32_t switchFromPort;
	while(itTo!=path.end()){
		switchFromPort = GetPortForwardEntry(*itFrom,*itTo);
		std::cout<<"FlowMod From: "<<*itFrom<<" To: "<<*itTo<<" ByPort: "<<switchFromPort<<std::endl;
		std::ostringstream flow;
		flow << "flow-mod table=0,cmd=add "
				//<<" eth_type="<<ethernetType
				//<<",ip_prot="<<ipProtocolNumber
				<<" eth_type=0x0800"
				<<",ip_src="<<ipSrc
				<<",ip_dst="<<ipDst
				<<" apply:output="<<switchFromPort;
		//<<" meter:1 apply:output="<<switchFromPort;//lo1
		DpctlExecute(GetRemoteSwitch(*itFrom),flow.str());
		++itFrom;
		++itTo;
	}
}








